{
  "address": "0x2eAcd6A408117D204DFcD73dDd133Da0F1421581",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "initialOwner",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "_baseURI",
          "type": "string"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "ERC721EnumerableForbiddenBatchMint",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "ERC721IncorrectOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ERC721InsufficientApproval",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "approver",
          "type": "address"
        }
      ],
      "name": "ERC721InvalidApprover",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "ERC721InvalidOperator",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "ERC721InvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "ERC721InvalidReceiver",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ERC721InvalidSender",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ERC721NonexistentToken",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "ERC721OutOfBoundsIndex",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "y",
          "type": "uint256"
        }
      ],
      "name": "PRBMath_MulDiv18_Overflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "UD60x18",
          "name": "x",
          "type": "uint256"
        }
      ],
      "name": "PRBMath_UD60x18_Log_InputTooSmall",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_fromTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_toTokenId",
          "type": "uint256"
        }
      ],
      "name": "BatchMetadataUpdate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        }
      ],
      "name": "MetadataUpdate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "NFTMinted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "_maxTokenId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "baseURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "burn",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "burnKey",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBurnPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getMintPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxTokenId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "mintKey",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "tokenByIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "tokenOfOwnerByIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x21c651e06463f33c52613696599b649c8386abd0d2c321858672c30d7dace91a",
  "receipt": {
    "to": null,
    "from": "0x460C6fF831472CF521251211865f13AE2B73ef59",
    "contractAddress": "0x2eAcd6A408117D204DFcD73dDd133Da0F1421581",
    "transactionIndex": 4,
    "gasUsed": "4071473",
    "logsBloom": "0x00000000000000020000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000080000000000000000020000000000000000000800000000000000000000008000000000400010000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x297f3b9eb1371aa3542ada94670563c9edaee834195f0b4dadeb8217ccd768e1",
    "transactionHash": "0x21c651e06463f33c52613696599b649c8386abd0d2c321858672c30d7dace91a",
    "logs": [
      {
        "transactionIndex": 4,
        "blockNumber": 51763369,
        "transactionHash": "0x21c651e06463f33c52613696599b649c8386abd0d2c321858672c30d7dace91a",
        "address": "0x2eAcd6A408117D204DFcD73dDd133Da0F1421581",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000460c6ff831472cf521251211865f13ae2b73ef59"
        ],
        "data": "0x",
        "logIndex": 25,
        "blockHash": "0x297f3b9eb1371aa3542ada94670563c9edaee834195f0b4dadeb8217ccd768e1"
      }
    ],
    "blockNumber": 51763369,
    "cumulativeGasUsed": "6200952",
    "status": 1,
    "byzantium": true
  },
  "args": ["0x460C6fF831472CF521251211865f13AE2B73ef59", "https://www.penx.io/api/believer-nft/"],
  "numDeployments": 2,
  "solcInputHash": "623225de6d3426d2a86ef4ad4645a736",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ERC721EnumerableForbiddenBatchMint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721IncorrectOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721InsufficientApproval\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC721InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721NonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ERC721OutOfBoundsIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"PRBMath_MulDiv18_Overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"UD60x18\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"PRBMath_UD60x18_Log_InputTooSmall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_toTokenId\",\"type\":\"uint256\"}],\"name\":\"BatchMetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"MetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NFTMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBurnPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintKey\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ERC721EnumerableForbiddenBatchMint()\":[{\"details\":\"Batch mint is not allowed.\"}],\"ERC721IncorrectOwner(address,uint256,address)\":[{\"details\":\"Indicates an error related to the ownership over a particular token. Used in transfers.\",\"params\":{\"owner\":\"Address of the current owner of a token.\",\"sender\":\"Address whose tokens are being transferred.\",\"tokenId\":\"Identifier number of a token.\"}}],\"ERC721InsufficientApproval(address,uint256)\":[{\"details\":\"Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\",\"params\":{\"operator\":\"Address that may be allowed to operate on tokens without being their owner.\",\"tokenId\":\"Identifier number of a token.\"}}],\"ERC721InvalidApprover(address)\":[{\"details\":\"Indicates a failure with the `approver` of a token to be approved. Used in approvals.\",\"params\":{\"approver\":\"Address initiating an approval operation.\"}}],\"ERC721InvalidOperator(address)\":[{\"details\":\"Indicates a failure with the `operator` to be approved. Used in approvals.\",\"params\":{\"operator\":\"Address that may be allowed to operate on tokens without being their owner.\"}}],\"ERC721InvalidOwner(address)\":[{\"details\":\"Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20. Used in balance queries.\",\"params\":{\"owner\":\"Address of the current owner of a token.\"}}],\"ERC721InvalidReceiver(address)\":[{\"details\":\"Indicates a failure with the token `receiver`. Used in transfers.\",\"params\":{\"receiver\":\"Address to which tokens are being transferred.\"}}],\"ERC721InvalidSender(address)\":[{\"details\":\"Indicates a failure with the token `sender`. Used in transfers.\",\"params\":{\"sender\":\"Address whose tokens are being transferred.\"}}],\"ERC721NonexistentToken(uint256)\":[{\"details\":\"Indicates a `tokenId` whose `owner` is the zero address.\",\"params\":{\"tokenId\":\"Identifier number of a token.\"}}],\"ERC721OutOfBoundsIndex(address,uint256)\":[{\"details\":\"An `owner`'s token query was out of bounds for `index`. NOTE: The owner being `address(0)` indicates a global out of bounds index.\"}],\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when `owner` enables `approved` to manage the `tokenId` token.\"},\"ApprovalForAll(address,address,bool)\":{\"details\":\"Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\"},\"BatchMetadataUpdate(uint256,uint256)\":{\"details\":\"This event emits when the metadata of a range of tokens is changed. So that the third-party platforms such as NFT market could timely update the images and related attributes of the NFTs.\"},\"MetadataUpdate(uint256)\":{\"details\":\"This event emits when the metadata of a token is changed. So that the third-party platforms such as NFT market could timely update the images and related attributes of the NFT.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `tokenId` token is transferred from `from` to `to`.\"}},\"kind\":\"dev\",\"methods\":{\"approve(address,uint256)\":{\"details\":\"See {IERC721-approve}.\"},\"balanceOf(address)\":{\"details\":\"See {IERC721-balanceOf}.\"},\"burn(uint256)\":{\"details\":\"Burns `tokenId`. See {ERC721-_burn}. Requirements: - The caller must own `tokenId` or be an approved operator.\"},\"getApproved(uint256)\":{\"details\":\"See {IERC721-getApproved}.\"},\"isApprovedForAll(address,address)\":{\"details\":\"See {IERC721-isApprovedForAll}.\"},\"name()\":{\"details\":\"See {IERC721Metadata-name}.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"ownerOf(uint256)\":{\"details\":\"See {IERC721-ownerOf}.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"safeTransferFrom(address,address,uint256)\":{\"details\":\"See {IERC721-safeTransferFrom}.\"},\"safeTransferFrom(address,address,uint256,bytes)\":{\"details\":\"See {IERC721-safeTransferFrom}.\"},\"setApprovalForAll(address,bool)\":{\"details\":\"See {IERC721-setApprovalForAll}.\"},\"symbol()\":{\"details\":\"See {IERC721Metadata-symbol}.\"},\"tokenByIndex(uint256)\":{\"details\":\"See {IERC721Enumerable-tokenByIndex}.\"},\"tokenOfOwnerByIndex(address,uint256)\":{\"details\":\"See {IERC721Enumerable-tokenOfOwnerByIndex}.\"},\"totalSupply()\":{\"details\":\"See {IERC721Enumerable-totalSupply}.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"See {IERC721-transferFrom}.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"errors\":{\"PRBMath_MulDiv18_Overflow(uint256,uint256)\":[{\"notice\":\"Thrown when the resultant value in {mulDiv18} overflows uint256.\"}],\"PRBMath_UD60x18_Log_InputTooSmall(uint256)\":[{\"notice\":\"Thrown when taking the logarithm of a number less than 1.\"}]},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/tokens/PenXKey.sol\":\"PenXKey\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":4294967295},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xde7e9fd9aee8d4f40772f96bb3b58836cbc6dfc0227014a061947f8821ea9724\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC4906.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4906.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\nimport {IERC721} from \\\"./IERC721.sol\\\";\\n\\n/// @title EIP-721 Metadata Update Extension\\ninterface IERC4906 is IERC165, IERC721 {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFT.\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    /// @dev This event emits when the metadata of a range of tokens is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFTs.\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\",\"keccak256\":\"0xb31b86c03f4677dcffa4655285d62433509513be9bafa0e04984565052d34e44\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"../token/ERC721/IERC721.sol\\\";\\n\",\"keccak256\":\"0xc4d7ebf63eb2f6bf3fee1b6c0ee775efa9f31b4843a5511d07eea147e212932d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\",\"keccak256\":\"0x60c65f701957fdd6faea1acb0bb45825791d473693ed9ecb34726fdfaa849dd7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"./IERC721.sol\\\";\\nimport {IERC721Receiver} from \\\"./IERC721Receiver.sol\\\";\\nimport {IERC721Metadata} from \\\"./extensions/IERC721Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {Strings} from \\\"../../utils/Strings.sol\\\";\\nimport {IERC165, ERC165} from \\\"../../utils/introspection/ERC165.sol\\\";\\nimport {IERC721Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    mapping(uint256 tokenId => address) private _owners;\\n\\n    mapping(address owner => uint256) private _balances;\\n\\n    mapping(uint256 tokenId => address) private _tokenApprovals;\\n\\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        if (owner == address(0)) {\\n            revert ERC721InvalidOwner(address(0));\\n        }\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\\n        return _requireOwned(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\\n        _requireOwned(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual {\\n        _approve(to, tokenId, _msgSender());\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\\n        _requireOwned(tokenId);\\n\\n        return _getApproved(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        // Setting an \\\"auth\\\" arguments enables the `_isAuthorized` check which verifies that the token exists\\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\\n        address previousOwner = _update(to, tokenId, _msgSender());\\n        if (previousOwner != from) {\\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\\n        transferFrom(from, to, tokenId);\\n        _checkOnERC721Received(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     *\\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\\n     */\\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\\n     * particular (ignoring whether it is owned by `owner`).\\n     *\\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\\n     * assumption.\\n     */\\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            spender != address(0) &&\\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\\n     * the `spender` for the specific `tokenId`.\\n     *\\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\\n     * assumption.\\n     */\\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\\n        if (!_isAuthorized(owner, spender, tokenId)) {\\n            if (owner == address(0)) {\\n                revert ERC721NonexistentToken(tokenId);\\n            } else {\\n                revert ERC721InsufficientApproval(spender, tokenId);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\\n     *\\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\\n     * remain consistent with one another.\\n     */\\n    function _increaseBalance(address account, uint128 value) internal virtual {\\n        unchecked {\\n            _balances[account] += value;\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\\n     *\\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\\n     */\\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\\n        address from = _ownerOf(tokenId);\\n\\n        // Perform (optional) operator check\\n        if (auth != address(0)) {\\n            _checkAuthorized(from, auth, tokenId);\\n        }\\n\\n        // Execute the update\\n        if (from != address(0)) {\\n            // Clear approval. No need to re-authorize or emit the Approval event\\n            _approve(address(0), tokenId, address(0), false);\\n\\n            unchecked {\\n                _balances[from] -= 1;\\n            }\\n        }\\n\\n        if (to != address(0)) {\\n            unchecked {\\n                _balances[to] += 1;\\n            }\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        return from;\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        address previousOwner = _update(to, tokenId, address(0));\\n        if (previousOwner != address(0)) {\\n            revert ERC721InvalidSender(address(0));\\n        }\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _mint(to, tokenId);\\n        _checkOnERC721Received(address(0), to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal {\\n        address previousOwner = _update(address(0), tokenId, address(0));\\n        if (previousOwner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        address previousOwner = _update(to, tokenId, address(0));\\n        if (previousOwner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        } else if (previousOwner != from) {\\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\\n        }\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - `to` cannot be the zero address.\\n     * - `from` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\\n        _safeTransfer(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        _checkOnERC721Received(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address to, uint256 tokenId, address auth) internal {\\n        _approve(to, tokenId, auth, true);\\n    }\\n\\n    /**\\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\\n     * emitted in the context of transfers.\\n     */\\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\\n        // Avoid reading the owner unless necessary\\n        if (emitEvent || auth != address(0)) {\\n            address owner = _requireOwned(tokenId);\\n\\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\\n                revert ERC721InvalidApprover(auth);\\n            }\\n\\n            if (emitEvent) {\\n                emit Approval(owner, to, tokenId);\\n            }\\n        }\\n\\n        _tokenApprovals[tokenId] = to;\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Requirements:\\n     * - operator can't be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        if (operator == address(0)) {\\n            revert ERC721InvalidOperator(operator);\\n        }\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\\n     * Returns the owner.\\n     *\\n     * Overrides to ownership logic should be done to {_ownerOf}.\\n     */\\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        if (owner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\\n        if (to.code.length > 0) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                if (retval != IERC721Receiver.onERC721Received.selector) {\\n                    revert ERC721InvalidReceiver(to);\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert ERC721InvalidReceiver(to);\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x13dd061770956c8489b80cfc89d9cdfc8ea2783d953691ea037a380731d52784\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5ef46daa3b58ef2702279d514780316efaa952915ee1aa3396f041ee2982b0b4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x7f7a26306c79a65fb8b3b6c757cd74660c532cd8a02e165488e30027dd34ca49\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721Burnable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC721} from \\\"../ERC721.sol\\\";\\nimport {Context} from \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @title ERC721 Burnable Token\\n * @dev ERC721 Token that can be burned (destroyed).\\n */\\nabstract contract ERC721Burnable is Context, ERC721 {\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) public virtual {\\n        // Setting an \\\"auth\\\" arguments enables the `_isAuthorized` check which verifies that the token exists\\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\\n        _update(address(0), tokenId, _msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0xc48434419baa510862ba4b4802bc0500ccddadd02ae2f195548af748c3206b20\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721Enumerable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC721} from \\\"../ERC721.sol\\\";\\nimport {IERC721Enumerable} from \\\"./IERC721Enumerable.sol\\\";\\nimport {IERC165} from \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds enumerability\\n * of all the token ids in the contract as well as all token ids owned by each account.\\n *\\n * CAUTION: `ERC721` extensions that implement custom `balanceOf` logic, such as `ERC721Consecutive`,\\n * interfere with enumerability and should not be used together with `ERC721Enumerable`.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    mapping(address owner => mapping(uint256 index => uint256)) private _ownedTokens;\\n    mapping(uint256 tokenId => uint256) private _ownedTokensIndex;\\n\\n    uint256[] private _allTokens;\\n    mapping(uint256 tokenId => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev An `owner`'s token query was out of bounds for `index`.\\n     *\\n     * NOTE: The owner being `address(0)` indicates a global out of bounds index.\\n     */\\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\\n\\n    /**\\n     * @dev Batch mint is not allowed.\\n     */\\n    error ERC721EnumerableForbiddenBatchMint();\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\\n        if (index >= balanceOf(owner)) {\\n            revert ERC721OutOfBoundsIndex(owner, index);\\n        }\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\\n        if (index >= totalSupply()) {\\n            revert ERC721OutOfBoundsIndex(address(0), index);\\n        }\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev See {ERC721-_update}.\\n     */\\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\\n        address previousOwner = super._update(to, tokenId, auth);\\n\\n        if (previousOwner == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (previousOwner != to) {\\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (previousOwner != to) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n\\n        return previousOwner;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = balanceOf(to) - 1;\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = balanceOf(from);\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n\\n    /**\\n     * See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch\\n     */\\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\\n        if (amount > 0) {\\n            revert ERC721EnumerableForbiddenBatchMint();\\n        }\\n        super._increaseBalance(account, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x36797469c391ea5ba27408e6ca8adf0824ba6f3adea9c139be18bd6f63232c16\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721URIStorage.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC721} from \\\"../ERC721.sol\\\";\\nimport {Strings} from \\\"../../../utils/Strings.sol\\\";\\nimport {IERC4906} from \\\"../../../interfaces/IERC4906.sol\\\";\\nimport {IERC165} from \\\"../../../interfaces/IERC165.sol\\\";\\n\\n/**\\n * @dev ERC721 token with storage based token URI management.\\n */\\nabstract contract ERC721URIStorage is IERC4906, ERC721 {\\n    using Strings for uint256;\\n\\n    // Interface ID as defined in ERC-4906. This does not correspond to a traditional interface ID as ERC-4906 only\\n    // defines events and does not include any external function.\\n    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);\\n\\n    // Optional mapping for token URIs\\n    mapping(uint256 tokenId => string) private _tokenURIs;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {\\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireOwned(tokenId);\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n        string memory base = _baseURI();\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(base).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via string.concat).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string.concat(base, _tokenURI);\\n        }\\n\\n        return super.tokenURI(tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Emits {MetadataUpdate}.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        _tokenURIs[tokenId] = _tokenURI;\\n        emit MetadataUpdate(tokenId);\\n    }\\n}\\n\",\"keccak256\":\"0xcc6f49e0c57072d6a18eef0d5fc22a4cc20462c18f0c365d2dd9a2c732fde670\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x3d6954a93ac198a2ffa384fa58ccf18e7e235263e051a394328002eff4e073de\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x37d1aaaa5a2908a09e9dcf56a26ddf762ecf295afb5964695937344fc6802ce1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x55f102ea785d8399c0e58d1108e2d289506dde18abc6db1b7f68c1f9f9bc5792\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x9e8778b14317ba9e256c30a76fd6c32b960af621987f56069e1e819c77c6a133\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5f7e4076e175393767754387c962926577f1660dd9b810187b9002407656be72\",\"license\":\"MIT\"},\"@prb/math/src/Common.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\n// Common.sol\\n//\\n// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\\n// always operate with SD59x18 and UD60x18 numbers.\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                CUSTOM ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\\n\\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\\n\\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\\nerror PRBMath_MulDivSigned_InputTooSmall();\\n\\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CONSTANTS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @dev The maximum value a uint128 number can have.\\nuint128 constant MAX_UINT128 = type(uint128).max;\\n\\n/// @dev The maximum value a uint40 number can have.\\nuint40 constant MAX_UINT40 = type(uint40).max;\\n\\n/// @dev The unit number, which the decimal precision of the fixed-point types.\\nuint256 constant UNIT = 1e18;\\n\\n/// @dev The unit number inverted mod 2^256.\\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\\n/// bit in the binary representation of `UNIT`.\\nuint256 constant UNIT_LPOTD = 262144;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction exp2(uint256 x) pure returns (uint256 result) {\\n    unchecked {\\n        // Start from 0.5 in the 192.64-bit fixed-point format.\\n        result = 0x800000000000000000000000000000000000000000000000;\\n\\n        // The following logic multiplies the result by $\\\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\\n        //\\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\\n        // we know that `x & 0xFF` is also 1.\\n        if (x & 0xFF00000000000000 > 0) {\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF000000000000 > 0) {\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF0000000000 > 0) {\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF00000000 > 0) {\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF000000 > 0) {\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF0000 > 0) {\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF00 > 0) {\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF > 0) {\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n        }\\n\\n        // In the code snippet below, two operations are executed simultaneously:\\n        //\\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\\n        //\\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\\n        // integer part, $2^n$.\\n        result *= UNIT;\\n        result >>= (191 - (x >> 64));\\n    }\\n}\\n\\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\\n///\\n/// @dev See the note on \\\"msb\\\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\\n///\\n/// Each step in this implementation is equivalent to this high-level code:\\n///\\n/// ```solidity\\n/// if (x >= 2 ** 128) {\\n///     x >>= 128;\\n///     result += 128;\\n/// }\\n/// ```\\n///\\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\\n///\\n/// The Yul instructions used below are:\\n///\\n/// - \\\"gt\\\" is \\\"greater than\\\"\\n/// - \\\"or\\\" is the OR bitwise operator\\n/// - \\\"shl\\\" is \\\"shift left\\\"\\n/// - \\\"shr\\\" is \\\"shift right\\\"\\n///\\n/// @param x The uint256 number for which to find the index of the most significant bit.\\n/// @return result The index of the most significant bit as a uint256.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction msb(uint256 x) pure returns (uint256 result) {\\n    // 2^128\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^64\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^32\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^16\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(4, gt(x, 0xFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^8\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(3, gt(x, 0xFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^4\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(2, gt(x, 0xF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^2\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(1, gt(x, 0x3))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^1\\n    // No need to shift x any more.\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := gt(x, 0x1)\\n        result := or(result, factor)\\n    }\\n}\\n\\n/// @notice Calculates x*y\\u00f7denominator with 512-bit precision.\\n///\\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n///\\n/// Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - The denominator must not be zero.\\n/// - The result must fit in uint256.\\n///\\n/// @param x The multiplicand as a uint256.\\n/// @param y The multiplier as a uint256.\\n/// @param denominator The divisor as a uint256.\\n/// @return result The result as a uint256.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n    uint256 prod0; // Least significant 256 bits of the product\\n    uint256 prod1; // Most significant 256 bits of the product\\n    assembly (\\\"memory-safe\\\") {\\n        let mm := mulmod(x, y, not(0))\\n        prod0 := mul(x, y)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n    if (prod1 == 0) {\\n        unchecked {\\n            return prod0 / denominator;\\n        }\\n    }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n    if (prod1 >= denominator) {\\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    // 512 by 256 division\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n    uint256 remainder;\\n    assembly (\\\"memory-safe\\\") {\\n        // Compute remainder using the mulmod Yul instruction.\\n        remainder := mulmod(x, y, denominator)\\n\\n        // Subtract 256 bit number from 512-bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n    }\\n\\n    unchecked {\\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\\n        uint256 lpotdod = denominator & (~denominator + 1);\\n        uint256 flippedLpotdod;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Factor powers of two out of denominator.\\n            denominator := div(denominator, lpotdod)\\n\\n            // Divide [prod1 prod0] by lpotdod.\\n            prod0 := div(prod0, lpotdod)\\n\\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n        }\\n\\n        // Shift in bits from prod1 into prod0.\\n        prod0 |= prod1 * flippedLpotdod;\\n\\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n        // four bits. That is, denominator * inv = 1 mod 2^4.\\n        uint256 inverse = (3 * denominator) ^ 2;\\n\\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n        // in modular arithmetic, doubling the correct bits in each step.\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inverse;\\n    }\\n}\\n\\n/// @notice Calculates x*y\\u00f71e18 with 512-bit precision.\\n///\\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\\n///\\n/// Notes:\\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\\n/// - The result is rounded toward zero.\\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\\n///\\n/// $$\\n/// \\\\begin{cases}\\n///     x * y = MAX\\\\_UINT256 * UNIT \\\\\\\\\\n///     (x * y) \\\\% UNIT \\\\geq \\\\frac{UNIT}{2}\\n/// \\\\end{cases}\\n/// $$\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {mulDiv}.\\n/// - The result must fit in uint256.\\n///\\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\\n    uint256 prod0;\\n    uint256 prod1;\\n    assembly (\\\"memory-safe\\\") {\\n        let mm := mulmod(x, y, not(0))\\n        prod0 := mul(x, y)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    if (prod1 == 0) {\\n        unchecked {\\n            return prod0 / UNIT;\\n        }\\n    }\\n\\n    if (prod1 >= UNIT) {\\n        revert PRBMath_MulDiv18_Overflow(x, y);\\n    }\\n\\n    uint256 remainder;\\n    assembly (\\\"memory-safe\\\") {\\n        remainder := mulmod(x, y, UNIT)\\n        result :=\\n            mul(\\n                or(\\n                    div(sub(prod0, remainder), UNIT_LPOTD),\\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\\n                ),\\n                UNIT_INVERSE\\n            )\\n    }\\n}\\n\\n/// @notice Calculates x*y\\u00f7denominator with 512-bit precision.\\n///\\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\\n///\\n/// Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {mulDiv}.\\n/// - None of the inputs can be `type(int256).min`.\\n/// - The result must fit in int256.\\n///\\n/// @param x The multiplicand as an int256.\\n/// @param y The multiplier as an int256.\\n/// @param denominator The divisor as an int256.\\n/// @return result The result as an int256.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n        revert PRBMath_MulDivSigned_InputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x, y and the denominator.\\n    uint256 xAbs;\\n    uint256 yAbs;\\n    uint256 dAbs;\\n    unchecked {\\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n    }\\n\\n    // Compute the absolute value of x*y\\u00f7denominator. The result must fit in int256.\\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\\n    if (resultAbs > uint256(type(int256).max)) {\\n        revert PRBMath_MulDivSigned_Overflow(x, y);\\n    }\\n\\n    // Get the signs of x, y and the denominator.\\n    uint256 sx;\\n    uint256 sy;\\n    uint256 sd;\\n    assembly (\\\"memory-safe\\\") {\\n        // \\\"sgt\\\" is the \\\"signed greater than\\\" assembly instruction and \\\"sub(0,1)\\\" is -1 in two's complement.\\n        sx := sgt(x, sub(0, 1))\\n        sy := sgt(y, sub(0, 1))\\n        sd := sgt(denominator, sub(0, 1))\\n    }\\n\\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\\n    // If there are, the result should be negative. Otherwise, it should be positive.\\n    unchecked {\\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\\n    }\\n}\\n\\n/// @notice Calculates the square root of x using the Babylonian method.\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n///\\n/// Notes:\\n/// - If x is not a perfect square, the result is rounded down.\\n/// - Credits to OpenZeppelin for the explanations in comments below.\\n///\\n/// @param x The uint256 number for which to calculate the square root.\\n/// @return result The result as a uint256.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction sqrt(uint256 x) pure returns (uint256 result) {\\n    if (x == 0) {\\n        return 0;\\n    }\\n\\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of x is a power of 2 such that we have:\\n    //\\n    // $$\\n    // msb(x) <= x <= 2*msb(x)$\\n    // $$\\n    //\\n    // We write $msb(x)$ as $2^k$, and we get:\\n    //\\n    // $$\\n    // k = log_2(x)\\n    // $$\\n    //\\n    // Thus, we can write the initial inequality as:\\n    //\\n    // $$\\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\\\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\\\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\\n    // $$\\n    //\\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\\n    uint256 xAux = uint256(x);\\n    result = 1;\\n    if (xAux >= 2 ** 128) {\\n        xAux >>= 128;\\n        result <<= 64;\\n    }\\n    if (xAux >= 2 ** 64) {\\n        xAux >>= 64;\\n        result <<= 32;\\n    }\\n    if (xAux >= 2 ** 32) {\\n        xAux >>= 32;\\n        result <<= 16;\\n    }\\n    if (xAux >= 2 ** 16) {\\n        xAux >>= 16;\\n        result <<= 8;\\n    }\\n    if (xAux >= 2 ** 8) {\\n        xAux >>= 8;\\n        result <<= 4;\\n    }\\n    if (xAux >= 2 ** 4) {\\n        xAux >>= 4;\\n        result <<= 2;\\n    }\\n    if (xAux >= 2 ** 2) {\\n        result <<= 1;\\n    }\\n\\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\\n    // precision into the expected uint128 result.\\n    unchecked {\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n\\n        // If x is not a perfect square, round the result toward zero.\\n        uint256 roundedResult = x / result;\\n        if (result >= roundedResult) {\\n            result = roundedResult;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaa374e2c26cc93e8c22a6953804ee05f811597ef5fa82f76824378b22944778b\",\"license\":\"MIT\"},\"@prb/math/src/UD60x18.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\n/*\\n\\n\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2557   \\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2557\\n\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u255a\\u2550\\u2550\\u2588\\u2588\\u2554\\u2550\\u2550\\u255d\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\n\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2554\\u2588\\u2588\\u2588\\u2588\\u2554\\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2551\\n\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u255d \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551\\u255a\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2551\\n\\u2588\\u2588\\u2551     \\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2551 \\u255a\\u2550\\u255d \\u2588\\u2588\\u2551\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\n\\u255a\\u2550\\u255d     \\u255a\\u2550\\u255d  \\u255a\\u2550\\u255d\\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d \\u255a\\u2550\\u255d     \\u255a\\u2550\\u255d\\u255a\\u2550\\u255d  \\u255a\\u2550\\u255d   \\u255a\\u2550\\u255d   \\u255a\\u2550\\u255d  \\u255a\\u2550\\u255d\\n\\n\\u2588\\u2588\\u2557   \\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2557  \\u2588\\u2588\\u2557 \\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\n\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255d \\u2588\\u2588\\u2554\\u2550\\u2588\\u2588\\u2588\\u2588\\u2557\\u255a\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\n\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2588\\u2588\\u2551 \\u255a\\u2588\\u2588\\u2588\\u2554\\u255d \\u255a\\u2588\\u2588\\u2551\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\n\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2551 \\u2588\\u2588\\u2554\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\n\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2554\\u255d \\u2588\\u2588\\u2557 \\u2588\\u2588\\u2551\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\n \\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d \\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d  \\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d  \\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d \\u255a\\u2550\\u255d  \\u255a\\u2550\\u255d \\u255a\\u2550\\u255d \\u255a\\u2550\\u2550\\u2550\\u2550\\u255d\\n\\n*/\\n\\nimport \\\"./ud60x18/Casting.sol\\\";\\nimport \\\"./ud60x18/Constants.sol\\\";\\nimport \\\"./ud60x18/Conversions.sol\\\";\\nimport \\\"./ud60x18/Errors.sol\\\";\\nimport \\\"./ud60x18/Helpers.sol\\\";\\nimport \\\"./ud60x18/Math.sol\\\";\\nimport \\\"./ud60x18/ValueType.sol\\\";\\n\",\"keccak256\":\"0xb98c6f74275914d279e8af6c502c2b1f50d5f6e1ed418d3b0153f5a193206c48\",\"license\":\"MIT\"},\"@prb/math/src/sd1x18/Casting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"../Common.sol\\\" as Common;\\nimport \\\"./Errors.sol\\\" as CastingErrors;\\nimport { SD59x18 } from \\\"../sd59x18/ValueType.sol\\\";\\nimport { UD2x18 } from \\\"../ud2x18/ValueType.sol\\\";\\nimport { UD60x18 } from \\\"../ud60x18/ValueType.sol\\\";\\nimport { SD1x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Casts an SD1x18 number into SD59x18.\\n/// @dev There is no overflow check because the domain of SD1x18 is a subset of SD59x18.\\nfunction intoSD59x18(SD1x18 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(int256(SD1x18.unwrap(x)));\\n}\\n\\n/// @notice Casts an SD1x18 number into UD2x18.\\n/// - x must be positive.\\nfunction intoUD2x18(SD1x18 x) pure returns (UD2x18 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD1x18_ToUD2x18_Underflow(x);\\n    }\\n    result = UD2x18.wrap(uint64(xInt));\\n}\\n\\n/// @notice Casts an SD1x18 number into UD60x18.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUD60x18(SD1x18 x) pure returns (UD60x18 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD1x18_ToUD60x18_Underflow(x);\\n    }\\n    result = UD60x18.wrap(uint64(xInt));\\n}\\n\\n/// @notice Casts an SD1x18 number into uint256.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUint256(SD1x18 x) pure returns (uint256 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD1x18_ToUint256_Underflow(x);\\n    }\\n    result = uint256(uint64(xInt));\\n}\\n\\n/// @notice Casts an SD1x18 number into uint128.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUint128(SD1x18 x) pure returns (uint128 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD1x18_ToUint128_Underflow(x);\\n    }\\n    result = uint128(uint64(xInt));\\n}\\n\\n/// @notice Casts an SD1x18 number into uint40.\\n/// @dev Requirements:\\n/// - x must be positive.\\n/// - x must be less than or equal to `MAX_UINT40`.\\nfunction intoUint40(SD1x18 x) pure returns (uint40 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD1x18_ToUint40_Underflow(x);\\n    }\\n    if (xInt > int64(uint64(Common.MAX_UINT40))) {\\n        revert CastingErrors.PRBMath_SD1x18_ToUint40_Overflow(x);\\n    }\\n    result = uint40(uint64(xInt));\\n}\\n\\n/// @notice Alias for {wrap}.\\nfunction sd1x18(int64 x) pure returns (SD1x18 result) {\\n    result = SD1x18.wrap(x);\\n}\\n\\n/// @notice Unwraps an SD1x18 number into int64.\\nfunction unwrap(SD1x18 x) pure returns (int64 result) {\\n    result = SD1x18.unwrap(x);\\n}\\n\\n/// @notice Wraps an int64 number into SD1x18.\\nfunction wrap(int64 x) pure returns (SD1x18 result) {\\n    result = SD1x18.wrap(x);\\n}\\n\",\"keccak256\":\"0x9e49e2b37c1bb845861740805edaaef3fe951a7b96eef16ce84fbf76e8278670\",\"license\":\"MIT\"},\"@prb/math/src/sd1x18/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { SD1x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @dev Euler's number as an SD1x18 number.\\nSD1x18 constant E = SD1x18.wrap(2_718281828459045235);\\n\\n/// @dev The maximum value an SD1x18 number can have.\\nint64 constant uMAX_SD1x18 = 9_223372036854775807;\\nSD1x18 constant MAX_SD1x18 = SD1x18.wrap(uMAX_SD1x18);\\n\\n/// @dev The maximum value an SD1x18 number can have.\\nint64 constant uMIN_SD1x18 = -9_223372036854775808;\\nSD1x18 constant MIN_SD1x18 = SD1x18.wrap(uMIN_SD1x18);\\n\\n/// @dev PI as an SD1x18 number.\\nSD1x18 constant PI = SD1x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit number, which gives the decimal precision of SD1x18.\\nSD1x18 constant UNIT = SD1x18.wrap(1e18);\\nint256 constant uUNIT = 1e18;\\n\",\"keccak256\":\"0xb51aab4a2ea76f530dccbf3b7d4af24c8f3ceef67f3c574b58650466ea924a3f\",\"license\":\"MIT\"},\"@prb/math/src/sd1x18/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { SD1x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Thrown when trying to cast a SD1x18 number that doesn't fit in UD2x18.\\nerror PRBMath_SD1x18_ToUD2x18_Underflow(SD1x18 x);\\n\\n/// @notice Thrown when trying to cast a SD1x18 number that doesn't fit in UD60x18.\\nerror PRBMath_SD1x18_ToUD60x18_Underflow(SD1x18 x);\\n\\n/// @notice Thrown when trying to cast a SD1x18 number that doesn't fit in uint128.\\nerror PRBMath_SD1x18_ToUint128_Underflow(SD1x18 x);\\n\\n/// @notice Thrown when trying to cast a SD1x18 number that doesn't fit in uint256.\\nerror PRBMath_SD1x18_ToUint256_Underflow(SD1x18 x);\\n\\n/// @notice Thrown when trying to cast a SD1x18 number that doesn't fit in uint40.\\nerror PRBMath_SD1x18_ToUint40_Overflow(SD1x18 x);\\n\\n/// @notice Thrown when trying to cast a SD1x18 number that doesn't fit in uint40.\\nerror PRBMath_SD1x18_ToUint40_Underflow(SD1x18 x);\\n\",\"keccak256\":\"0x836cb42ba619ca369fd4765bc47fefc3c3621369c5861882af14660aca5057ee\",\"license\":\"MIT\"},\"@prb/math/src/sd1x18/ValueType.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"./Casting.sol\\\" as Casting;\\n\\n/// @notice The signed 1.18-decimal fixed-point number representation, which can have up to 1 digit and up to 18\\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\\n/// type int64. This is useful when end users want to use int64 to save gas, e.g. with tight variable packing in contract\\n/// storage.\\ntype SD1x18 is int64;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CASTING\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    Casting.intoSD59x18,\\n    Casting.intoUD2x18,\\n    Casting.intoUD60x18,\\n    Casting.intoUint256,\\n    Casting.intoUint128,\\n    Casting.intoUint40,\\n    Casting.unwrap\\n} for SD1x18 global;\\n\",\"keccak256\":\"0x2f86f1aa9fca42f40808b51a879b406ac51817647bdb9642f8a79dd8fdb754a7\",\"license\":\"MIT\"},\"@prb/math/src/sd59x18/Casting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"./Errors.sol\\\" as CastingErrors;\\nimport { MAX_UINT128, MAX_UINT40 } from \\\"../Common.sol\\\";\\nimport { uMAX_SD1x18, uMIN_SD1x18 } from \\\"../sd1x18/Constants.sol\\\";\\nimport { SD1x18 } from \\\"../sd1x18/ValueType.sol\\\";\\nimport { uMAX_UD2x18 } from \\\"../ud2x18/Constants.sol\\\";\\nimport { UD2x18 } from \\\"../ud2x18/ValueType.sol\\\";\\nimport { UD60x18 } from \\\"../ud60x18/ValueType.sol\\\";\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Casts an SD59x18 number into int256.\\n/// @dev This is basically a functional alias for {unwrap}.\\nfunction intoInt256(SD59x18 x) pure returns (int256 result) {\\n    result = SD59x18.unwrap(x);\\n}\\n\\n/// @notice Casts an SD59x18 number into SD1x18.\\n/// @dev Requirements:\\n/// - x must be greater than or equal to `uMIN_SD1x18`.\\n/// - x must be less than or equal to `uMAX_SD1x18`.\\nfunction intoSD1x18(SD59x18 x) pure returns (SD1x18 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < uMIN_SD1x18) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoSD1x18_Underflow(x);\\n    }\\n    if (xInt > uMAX_SD1x18) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoSD1x18_Overflow(x);\\n    }\\n    result = SD1x18.wrap(int64(xInt));\\n}\\n\\n/// @notice Casts an SD59x18 number into UD2x18.\\n/// @dev Requirements:\\n/// - x must be positive.\\n/// - x must be less than or equal to `uMAX_UD2x18`.\\nfunction intoUD2x18(SD59x18 x) pure returns (UD2x18 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUD2x18_Underflow(x);\\n    }\\n    if (xInt > int256(uint256(uMAX_UD2x18))) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUD2x18_Overflow(x);\\n    }\\n    result = UD2x18.wrap(uint64(uint256(xInt)));\\n}\\n\\n/// @notice Casts an SD59x18 number into UD60x18.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUD60x18(SD59x18 x) pure returns (UD60x18 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUD60x18_Underflow(x);\\n    }\\n    result = UD60x18.wrap(uint256(xInt));\\n}\\n\\n/// @notice Casts an SD59x18 number into uint256.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUint256(SD59x18 x) pure returns (uint256 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUint256_Underflow(x);\\n    }\\n    result = uint256(xInt);\\n}\\n\\n/// @notice Casts an SD59x18 number into uint128.\\n/// @dev Requirements:\\n/// - x must be positive.\\n/// - x must be less than or equal to `uMAX_UINT128`.\\nfunction intoUint128(SD59x18 x) pure returns (uint128 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUint128_Underflow(x);\\n    }\\n    if (xInt > int256(uint256(MAX_UINT128))) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUint128_Overflow(x);\\n    }\\n    result = uint128(uint256(xInt));\\n}\\n\\n/// @notice Casts an SD59x18 number into uint40.\\n/// @dev Requirements:\\n/// - x must be positive.\\n/// - x must be less than or equal to `MAX_UINT40`.\\nfunction intoUint40(SD59x18 x) pure returns (uint40 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUint40_Underflow(x);\\n    }\\n    if (xInt > int256(uint256(MAX_UINT40))) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUint40_Overflow(x);\\n    }\\n    result = uint40(uint256(xInt));\\n}\\n\\n/// @notice Alias for {wrap}.\\nfunction sd(int256 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(x);\\n}\\n\\n/// @notice Alias for {wrap}.\\nfunction sd59x18(int256 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(x);\\n}\\n\\n/// @notice Unwraps an SD59x18 number into int256.\\nfunction unwrap(SD59x18 x) pure returns (int256 result) {\\n    result = SD59x18.unwrap(x);\\n}\\n\\n/// @notice Wraps an int256 number into SD59x18.\\nfunction wrap(int256 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(x);\\n}\\n\",\"keccak256\":\"0x3b21b60ec2998c3ae32f647412da51d3683b3f183a807198cc8d157499484f99\",\"license\":\"MIT\"},\"@prb/math/src/sd59x18/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n// NOTICE: the \\\"u\\\" prefix stands for \\\"unwrapped\\\".\\n\\n/// @dev Euler's number as an SD59x18 number.\\nSD59x18 constant E = SD59x18.wrap(2_718281828459045235);\\n\\n/// @dev The maximum input permitted in {exp}.\\nint256 constant uEXP_MAX_INPUT = 133_084258667509499440;\\nSD59x18 constant EXP_MAX_INPUT = SD59x18.wrap(uEXP_MAX_INPUT);\\n\\n/// @dev The maximum input permitted in {exp2}.\\nint256 constant uEXP2_MAX_INPUT = 192e18 - 1;\\nSD59x18 constant EXP2_MAX_INPUT = SD59x18.wrap(uEXP2_MAX_INPUT);\\n\\n/// @dev Half the UNIT number.\\nint256 constant uHALF_UNIT = 0.5e18;\\nSD59x18 constant HALF_UNIT = SD59x18.wrap(uHALF_UNIT);\\n\\n/// @dev $log_2(10)$ as an SD59x18 number.\\nint256 constant uLOG2_10 = 3_321928094887362347;\\nSD59x18 constant LOG2_10 = SD59x18.wrap(uLOG2_10);\\n\\n/// @dev $log_2(e)$ as an SD59x18 number.\\nint256 constant uLOG2_E = 1_442695040888963407;\\nSD59x18 constant LOG2_E = SD59x18.wrap(uLOG2_E);\\n\\n/// @dev The maximum value an SD59x18 number can have.\\nint256 constant uMAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_792003956564819967;\\nSD59x18 constant MAX_SD59x18 = SD59x18.wrap(uMAX_SD59x18);\\n\\n/// @dev The maximum whole value an SD59x18 number can have.\\nint256 constant uMAX_WHOLE_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\nSD59x18 constant MAX_WHOLE_SD59x18 = SD59x18.wrap(uMAX_WHOLE_SD59x18);\\n\\n/// @dev The minimum value an SD59x18 number can have.\\nint256 constant uMIN_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\\nSD59x18 constant MIN_SD59x18 = SD59x18.wrap(uMIN_SD59x18);\\n\\n/// @dev The minimum whole value an SD59x18 number can have.\\nint256 constant uMIN_WHOLE_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\nSD59x18 constant MIN_WHOLE_SD59x18 = SD59x18.wrap(uMIN_WHOLE_SD59x18);\\n\\n/// @dev PI as an SD59x18 number.\\nSD59x18 constant PI = SD59x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit number, which gives the decimal precision of SD59x18.\\nint256 constant uUNIT = 1e18;\\nSD59x18 constant UNIT = SD59x18.wrap(1e18);\\n\\n/// @dev The unit number squared.\\nint256 constant uUNIT_SQUARED = 1e36;\\nSD59x18 constant UNIT_SQUARED = SD59x18.wrap(uUNIT_SQUARED);\\n\\n/// @dev Zero as an SD59x18 number.\\nSD59x18 constant ZERO = SD59x18.wrap(0);\\n\",\"keccak256\":\"0xe0a1ca1a7b5b2d637cff83a8caa3d2e67a6a34f7ee9df58a9ca5d5fa268c474a\",\"license\":\"MIT\"},\"@prb/math/src/sd59x18/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Thrown when taking the absolute value of `MIN_SD59x18`.\\nerror PRBMath_SD59x18_Abs_MinSD59x18();\\n\\n/// @notice Thrown when ceiling a number overflows SD59x18.\\nerror PRBMath_SD59x18_Ceil_Overflow(SD59x18 x);\\n\\n/// @notice Thrown when converting a basic integer to the fixed-point format overflows SD59x18.\\nerror PRBMath_SD59x18_Convert_Overflow(int256 x);\\n\\n/// @notice Thrown when converting a basic integer to the fixed-point format underflows SD59x18.\\nerror PRBMath_SD59x18_Convert_Underflow(int256 x);\\n\\n/// @notice Thrown when dividing two numbers and one of them is `MIN_SD59x18`.\\nerror PRBMath_SD59x18_Div_InputTooSmall();\\n\\n/// @notice Thrown when dividing two numbers and one of the intermediary unsigned results overflows SD59x18.\\nerror PRBMath_SD59x18_Div_Overflow(SD59x18 x, SD59x18 y);\\n\\n/// @notice Thrown when taking the natural exponent of a base greater than 133_084258667509499441.\\nerror PRBMath_SD59x18_Exp_InputTooBig(SD59x18 x);\\n\\n/// @notice Thrown when taking the binary exponent of a base greater than 192e18.\\nerror PRBMath_SD59x18_Exp2_InputTooBig(SD59x18 x);\\n\\n/// @notice Thrown when flooring a number underflows SD59x18.\\nerror PRBMath_SD59x18_Floor_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when taking the geometric mean of two numbers and their product is negative.\\nerror PRBMath_SD59x18_Gm_NegativeProduct(SD59x18 x, SD59x18 y);\\n\\n/// @notice Thrown when taking the geometric mean of two numbers and multiplying them overflows SD59x18.\\nerror PRBMath_SD59x18_Gm_Overflow(SD59x18 x, SD59x18 y);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD1x18.\\nerror PRBMath_SD59x18_IntoSD1x18_Overflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD1x18.\\nerror PRBMath_SD59x18_IntoSD1x18_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in UD2x18.\\nerror PRBMath_SD59x18_IntoUD2x18_Overflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in UD2x18.\\nerror PRBMath_SD59x18_IntoUD2x18_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in UD60x18.\\nerror PRBMath_SD59x18_IntoUD60x18_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint128.\\nerror PRBMath_SD59x18_IntoUint128_Overflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint128.\\nerror PRBMath_SD59x18_IntoUint128_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint256.\\nerror PRBMath_SD59x18_IntoUint256_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint40.\\nerror PRBMath_SD59x18_IntoUint40_Overflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint40.\\nerror PRBMath_SD59x18_IntoUint40_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when taking the logarithm of a number less than or equal to zero.\\nerror PRBMath_SD59x18_Log_InputTooSmall(SD59x18 x);\\n\\n/// @notice Thrown when multiplying two numbers and one of the inputs is `MIN_SD59x18`.\\nerror PRBMath_SD59x18_Mul_InputTooSmall();\\n\\n/// @notice Thrown when multiplying two numbers and the intermediary absolute result overflows SD59x18.\\nerror PRBMath_SD59x18_Mul_Overflow(SD59x18 x, SD59x18 y);\\n\\n/// @notice Thrown when raising a number to a power and the intermediary absolute result overflows SD59x18.\\nerror PRBMath_SD59x18_Powu_Overflow(SD59x18 x, uint256 y);\\n\\n/// @notice Thrown when taking the square root of a negative number.\\nerror PRBMath_SD59x18_Sqrt_NegativeInput(SD59x18 x);\\n\\n/// @notice Thrown when the calculating the square root overflows SD59x18.\\nerror PRBMath_SD59x18_Sqrt_Overflow(SD59x18 x);\\n\",\"keccak256\":\"0xa6d00fe5efa215ac0df25c896e3da99a12fb61e799644b2ec32da947313d3db4\",\"license\":\"MIT\"},\"@prb/math/src/sd59x18/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { wrap } from \\\"./Casting.sol\\\";\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Implements the checked addition operation (+) in the SD59x18 type.\\nfunction add(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    return wrap(x.unwrap() + y.unwrap());\\n}\\n\\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\\nfunction and(SD59x18 x, int256 bits) pure returns (SD59x18 result) {\\n    return wrap(x.unwrap() & bits);\\n}\\n\\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\\nfunction and2(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    return wrap(x.unwrap() & y.unwrap());\\n}\\n\\n/// @notice Implements the equal (=) operation in the SD59x18 type.\\nfunction eq(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = x.unwrap() == y.unwrap();\\n}\\n\\n/// @notice Implements the greater than operation (>) in the SD59x18 type.\\nfunction gt(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = x.unwrap() > y.unwrap();\\n}\\n\\n/// @notice Implements the greater than or equal to operation (>=) in the SD59x18 type.\\nfunction gte(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = x.unwrap() >= y.unwrap();\\n}\\n\\n/// @notice Implements a zero comparison check function in the SD59x18 type.\\nfunction isZero(SD59x18 x) pure returns (bool result) {\\n    result = x.unwrap() == 0;\\n}\\n\\n/// @notice Implements the left shift operation (<<) in the SD59x18 type.\\nfunction lshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() << bits);\\n}\\n\\n/// @notice Implements the lower than operation (<) in the SD59x18 type.\\nfunction lt(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = x.unwrap() < y.unwrap();\\n}\\n\\n/// @notice Implements the lower than or equal to operation (<=) in the SD59x18 type.\\nfunction lte(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = x.unwrap() <= y.unwrap();\\n}\\n\\n/// @notice Implements the unchecked modulo operation (%) in the SD59x18 type.\\nfunction mod(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() % y.unwrap());\\n}\\n\\n/// @notice Implements the not equal operation (!=) in the SD59x18 type.\\nfunction neq(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = x.unwrap() != y.unwrap();\\n}\\n\\n/// @notice Implements the NOT (~) bitwise operation in the SD59x18 type.\\nfunction not(SD59x18 x) pure returns (SD59x18 result) {\\n    result = wrap(~x.unwrap());\\n}\\n\\n/// @notice Implements the OR (|) bitwise operation in the SD59x18 type.\\nfunction or(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() | y.unwrap());\\n}\\n\\n/// @notice Implements the right shift operation (>>) in the SD59x18 type.\\nfunction rshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() >> bits);\\n}\\n\\n/// @notice Implements the checked subtraction operation (-) in the SD59x18 type.\\nfunction sub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() - y.unwrap());\\n}\\n\\n/// @notice Implements the checked unary minus operation (-) in the SD59x18 type.\\nfunction unary(SD59x18 x) pure returns (SD59x18 result) {\\n    result = wrap(-x.unwrap());\\n}\\n\\n/// @notice Implements the unchecked addition operation (+) in the SD59x18 type.\\nfunction uncheckedAdd(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(x.unwrap() + y.unwrap());\\n    }\\n}\\n\\n/// @notice Implements the unchecked subtraction operation (-) in the SD59x18 type.\\nfunction uncheckedSub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(x.unwrap() - y.unwrap());\\n    }\\n}\\n\\n/// @notice Implements the unchecked unary minus operation (-) in the SD59x18 type.\\nfunction uncheckedUnary(SD59x18 x) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(-x.unwrap());\\n    }\\n}\\n\\n/// @notice Implements the XOR (^) bitwise operation in the SD59x18 type.\\nfunction xor(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() ^ y.unwrap());\\n}\\n\",\"keccak256\":\"0x208570f1657cf730cb6c3d81aa14030e0d45cf906cdedea5059369d7df4bb716\",\"license\":\"MIT\"},\"@prb/math/src/sd59x18/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"../Common.sol\\\" as Common;\\nimport \\\"./Errors.sol\\\" as Errors;\\nimport {\\n    uEXP_MAX_INPUT,\\n    uEXP2_MAX_INPUT,\\n    uHALF_UNIT,\\n    uLOG2_10,\\n    uLOG2_E,\\n    uMAX_SD59x18,\\n    uMAX_WHOLE_SD59x18,\\n    uMIN_SD59x18,\\n    uMIN_WHOLE_SD59x18,\\n    UNIT,\\n    uUNIT,\\n    uUNIT_SQUARED,\\n    ZERO\\n} from \\\"./Constants.sol\\\";\\nimport { wrap } from \\\"./Helpers.sol\\\";\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Calculates the absolute value of x.\\n///\\n/// @dev Requirements:\\n/// - x must be greater than `MIN_SD59x18`.\\n///\\n/// @param x The SD59x18 number for which to calculate the absolute value.\\n/// @param result The absolute value of x as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction abs(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt == uMIN_SD59x18) {\\n        revert Errors.PRBMath_SD59x18_Abs_MinSD59x18();\\n    }\\n    result = xInt < 0 ? wrap(-xInt) : x;\\n}\\n\\n/// @notice Calculates the arithmetic average of x and y.\\n///\\n/// @dev Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// @param x The first operand as an SD59x18 number.\\n/// @param y The second operand as an SD59x18 number.\\n/// @return result The arithmetic average as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction avg(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    int256 yInt = y.unwrap();\\n\\n    unchecked {\\n        // This operation is equivalent to `x / 2 +  y / 2`, and it can never overflow.\\n        int256 sum = (xInt >> 1) + (yInt >> 1);\\n\\n        if (sum < 0) {\\n            // If at least one of x and y is odd, add 1 to the result, because shifting negative numbers to the right\\n            // rounds toward negative infinity. The right part is equivalent to `sum + (x % 2 == 1 || y % 2 == 1)`.\\n            assembly (\\\"memory-safe\\\") {\\n                result := add(sum, and(or(xInt, yInt), 1))\\n            }\\n        } else {\\n            // Add 1 if both x and y are odd to account for the double 0.5 remainder truncated after shifting.\\n            result = wrap(sum + (xInt & yInt & 1));\\n        }\\n    }\\n}\\n\\n/// @notice Yields the smallest whole number greater than or equal to x.\\n///\\n/// @dev Optimized for fractional value inputs, because every whole value has (1e18 - 1) fractional counterparts.\\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n///\\n/// Requirements:\\n/// - x must be less than or equal to `MAX_WHOLE_SD59x18`.\\n///\\n/// @param x The SD59x18 number to ceil.\\n/// @param result The smallest whole number greater than or equal to x, as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction ceil(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt > uMAX_WHOLE_SD59x18) {\\n        revert Errors.PRBMath_SD59x18_Ceil_Overflow(x);\\n    }\\n\\n    int256 remainder = xInt % uUNIT;\\n    if (remainder == 0) {\\n        result = x;\\n    } else {\\n        unchecked {\\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n            int256 resultInt = xInt - remainder;\\n            if (xInt > 0) {\\n                resultInt += uUNIT;\\n            }\\n            result = wrap(resultInt);\\n        }\\n    }\\n}\\n\\n/// @notice Divides two SD59x18 numbers, returning a new SD59x18 number.\\n///\\n/// @dev This is an extension of {Common.mulDiv} for signed numbers, which works by computing the signs and the absolute\\n/// values separately.\\n///\\n/// Notes:\\n/// - Refer to the notes in {Common.mulDiv}.\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {Common.mulDiv}.\\n/// - None of the inputs can be `MIN_SD59x18`.\\n/// - The denominator must not be zero.\\n/// - The result must fit in SD59x18.\\n///\\n/// @param x The numerator as an SD59x18 number.\\n/// @param y The denominator as an SD59x18 number.\\n/// @param result The quotient as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction div(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    int256 yInt = y.unwrap();\\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\\n        revert Errors.PRBMath_SD59x18_Div_InputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x and y.\\n    uint256 xAbs;\\n    uint256 yAbs;\\n    unchecked {\\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\\n    }\\n\\n    // Compute the absolute value (x*UNIT\\u00f7y). The resulting value must fit in SD59x18.\\n    uint256 resultAbs = Common.mulDiv(xAbs, uint256(uUNIT), yAbs);\\n    if (resultAbs > uint256(uMAX_SD59x18)) {\\n        revert Errors.PRBMath_SD59x18_Div_Overflow(x, y);\\n    }\\n\\n    // Check if x and y have the same sign using two's complement representation. The left-most bit represents the sign (1 for\\n    // negative, 0 for positive or zero).\\n    bool sameSign = (xInt ^ yInt) > -1;\\n\\n    // If the inputs have the same sign, the result should be positive. Otherwise, it should be negative.\\n    unchecked {\\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\\n    }\\n}\\n\\n/// @notice Calculates the natural exponent of x using the following formula:\\n///\\n/// $$\\n/// e^x = 2^{x * log_2{e}}\\n/// $$\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {exp2}.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {exp2}.\\n/// - x must be less than 133_084258667509499441.\\n///\\n/// @param x The exponent as an SD59x18 number.\\n/// @return result The result as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction exp(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n\\n    // This check prevents values greater than 192e18 from being passed to {exp2}.\\n    if (xInt > uEXP_MAX_INPUT) {\\n        revert Errors.PRBMath_SD59x18_Exp_InputTooBig(x);\\n    }\\n\\n    unchecked {\\n        // Inline the fixed-point multiplication to save gas.\\n        int256 doubleUnitProduct = xInt * uLOG2_E;\\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\\n    }\\n}\\n\\n/// @notice Calculates the binary exponent of x using the binary fraction method using the following formula:\\n///\\n/// $$\\n/// 2^{-x} = \\\\frac{1}{2^x}\\n/// $$\\n///\\n/// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n///\\n/// Notes:\\n/// - If x is less than -59_794705707972522261, the result is zero.\\n///\\n/// Requirements:\\n/// - x must be less than 192e18.\\n/// - The result must fit in SD59x18.\\n///\\n/// @param x The exponent as an SD59x18 number.\\n/// @return result The result as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction exp2(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt < 0) {\\n        // The inverse of any number less than this is truncated to zero.\\n        if (xInt < -59_794705707972522261) {\\n            return ZERO;\\n        }\\n\\n        unchecked {\\n            // Inline the fixed-point inversion to save gas.\\n            result = wrap(uUNIT_SQUARED / exp2(wrap(-xInt)).unwrap());\\n        }\\n    } else {\\n        // Numbers greater than or equal to 192e18 don't fit in the 192.64-bit format.\\n        if (xInt > uEXP2_MAX_INPUT) {\\n            revert Errors.PRBMath_SD59x18_Exp2_InputTooBig(x);\\n        }\\n\\n        unchecked {\\n            // Convert x to the 192.64-bit fixed-point format.\\n            uint256 x_192x64 = uint256((xInt << 64) / uUNIT);\\n\\n            // It is safe to cast the result to int256 due to the checks above.\\n            result = wrap(int256(Common.exp2(x_192x64)));\\n        }\\n    }\\n}\\n\\n/// @notice Yields the greatest whole number less than or equal to x.\\n///\\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional\\n/// counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n///\\n/// Requirements:\\n/// - x must be greater than or equal to `MIN_WHOLE_SD59x18`.\\n///\\n/// @param x The SD59x18 number to floor.\\n/// @param result The greatest whole number less than or equal to x, as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction floor(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt < uMIN_WHOLE_SD59x18) {\\n        revert Errors.PRBMath_SD59x18_Floor_Underflow(x);\\n    }\\n\\n    int256 remainder = xInt % uUNIT;\\n    if (remainder == 0) {\\n        result = x;\\n    } else {\\n        unchecked {\\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n            int256 resultInt = xInt - remainder;\\n            if (xInt < 0) {\\n                resultInt -= uUNIT;\\n            }\\n            result = wrap(resultInt);\\n        }\\n    }\\n}\\n\\n/// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right.\\n/// of the radix point for negative numbers.\\n/// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\\n/// @param x The SD59x18 number to get the fractional part of.\\n/// @param result The fractional part of x as an SD59x18 number.\\nfunction frac(SD59x18 x) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() % uUNIT);\\n}\\n\\n/// @notice Calculates the geometric mean of x and y, i.e. $\\\\sqrt{x * y}$.\\n///\\n/// @dev Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - x * y must fit in SD59x18.\\n/// - x * y must not be negative, since complex numbers are not supported.\\n///\\n/// @param x The first operand as an SD59x18 number.\\n/// @param y The second operand as an SD59x18 number.\\n/// @return result The result as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction gm(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    int256 yInt = y.unwrap();\\n    if (xInt == 0 || yInt == 0) {\\n        return ZERO;\\n    }\\n\\n    unchecked {\\n        // Equivalent to `xy / x != y`. Checking for overflow this way is faster than letting Solidity do it.\\n        int256 xyInt = xInt * yInt;\\n        if (xyInt / xInt != yInt) {\\n            revert Errors.PRBMath_SD59x18_Gm_Overflow(x, y);\\n        }\\n\\n        // The product must not be negative, since complex numbers are not supported.\\n        if (xyInt < 0) {\\n            revert Errors.PRBMath_SD59x18_Gm_NegativeProduct(x, y);\\n        }\\n\\n        // We don't need to multiply the result by `UNIT` here because the x*y product picked up a factor of `UNIT`\\n        // during multiplication. See the comments in {Common.sqrt}.\\n        uint256 resultUint = Common.sqrt(uint256(xyInt));\\n        result = wrap(int256(resultUint));\\n    }\\n}\\n\\n/// @notice Calculates the inverse of x.\\n///\\n/// @dev Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - x must not be zero.\\n///\\n/// @param x The SD59x18 number for which to calculate the inverse.\\n/// @return result The inverse as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction inv(SD59x18 x) pure returns (SD59x18 result) {\\n    result = wrap(uUNIT_SQUARED / x.unwrap());\\n}\\n\\n/// @notice Calculates the natural logarithm of x using the following formula:\\n///\\n/// $$\\n/// ln{x} = log_2{x} / log_2{e}\\n/// $$\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {log2}.\\n/// - The precision isn't sufficiently fine-grained to return exactly `UNIT` when the input is `E`.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {log2}.\\n///\\n/// @param x The SD59x18 number for which to calculate the natural logarithm.\\n/// @return result The natural logarithm as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction ln(SD59x18 x) pure returns (SD59x18 result) {\\n    // Inline the fixed-point multiplication to save gas. This is overflow-safe because the maximum value that\\n    // {log2} can return is ~195_205294292027477728.\\n    result = wrap(log2(x).unwrap() * uUNIT / uLOG2_E);\\n}\\n\\n/// @notice Calculates the common logarithm of x using the following formula:\\n///\\n/// $$\\n/// log_{10}{x} = log_2{x} / log_2{10}\\n/// $$\\n///\\n/// However, if x is an exact power of ten, a hard coded value is returned.\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {log2}.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {log2}.\\n///\\n/// @param x The SD59x18 number for which to calculate the common logarithm.\\n/// @return result The common logarithm as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction log10(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt < 0) {\\n        revert Errors.PRBMath_SD59x18_Log_InputTooSmall(x);\\n    }\\n\\n    // Note that the `mul` in this block is the standard multiplication operation, not {SD59x18.mul}.\\n    // prettier-ignore\\n    assembly (\\\"memory-safe\\\") {\\n        switch x\\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\\n        case 1000000000000000000 { result := 0 }\\n        case 10000000000000000000 { result := uUNIT }\\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\\n        default { result := uMAX_SD59x18 }\\n    }\\n\\n    if (result.unwrap() == uMAX_SD59x18) {\\n        unchecked {\\n            // Inline the fixed-point division to save gas.\\n            result = wrap(log2(x).unwrap() * uUNIT / uLOG2_10);\\n        }\\n    }\\n}\\n\\n/// @notice Calculates the binary logarithm of x using the iterative approximation algorithm:\\n///\\n/// $$\\n/// log_2{x} = n + log_2{y}, \\\\text{ where } y = x*2^{-n}, \\\\ y \\\\in [1, 2)\\n/// $$\\n///\\n/// For $0 \\\\leq x \\\\lt 1$, the input is inverted:\\n///\\n/// $$\\n/// log_2{x} = -log_2{\\\\frac{1}{x}}\\n/// $$\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation.\\n///\\n/// Notes:\\n/// - Due to the lossy precision of the iterative approximation, the results are not perfectly accurate to the last decimal.\\n///\\n/// Requirements:\\n/// - x must be greater than zero.\\n///\\n/// @param x The SD59x18 number for which to calculate the binary logarithm.\\n/// @return result The binary logarithm as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction log2(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt <= 0) {\\n        revert Errors.PRBMath_SD59x18_Log_InputTooSmall(x);\\n    }\\n\\n    unchecked {\\n        int256 sign;\\n        if (xInt >= uUNIT) {\\n            sign = 1;\\n        } else {\\n            sign = -1;\\n            // Inline the fixed-point inversion to save gas.\\n            xInt = uUNIT_SQUARED / xInt;\\n        }\\n\\n        // Calculate the integer part of the logarithm.\\n        uint256 n = Common.msb(uint256(xInt / uUNIT));\\n\\n        // This is the integer part of the logarithm as an SD59x18 number. The operation can't overflow\\n        // because n is at most 255, `UNIT` is 1e18, and the sign is either 1 or -1.\\n        int256 resultInt = int256(n) * uUNIT;\\n\\n        // Calculate $y = x * 2^{-n}$.\\n        int256 y = xInt >> n;\\n\\n        // If y is the unit number, the fractional part is zero.\\n        if (y == uUNIT) {\\n            return wrap(resultInt * sign);\\n        }\\n\\n        // Calculate the fractional part via the iterative approximation.\\n        // The `delta >>= 1` part is equivalent to `delta /= 2`, but shifting bits is more gas efficient.\\n        int256 DOUBLE_UNIT = 2e18;\\n        for (int256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\\n            y = (y * y) / uUNIT;\\n\\n            // Is y^2 >= 2e18 and so in the range [2e18, 4e18)?\\n            if (y >= DOUBLE_UNIT) {\\n                // Add the 2^{-m} factor to the logarithm.\\n                resultInt = resultInt + delta;\\n\\n                // Halve y, which corresponds to z/2 in the Wikipedia article.\\n                y >>= 1;\\n            }\\n        }\\n        resultInt *= sign;\\n        result = wrap(resultInt);\\n    }\\n}\\n\\n/// @notice Multiplies two SD59x18 numbers together, returning a new SD59x18 number.\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {Common.mulDiv18}.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {Common.mulDiv18}.\\n/// - None of the inputs can be `MIN_SD59x18`.\\n/// - The result must fit in SD59x18.\\n///\\n/// @param x The multiplicand as an SD59x18 number.\\n/// @param y The multiplier as an SD59x18 number.\\n/// @return result The product as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mul(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    int256 yInt = y.unwrap();\\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\\n        revert Errors.PRBMath_SD59x18_Mul_InputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x and y.\\n    uint256 xAbs;\\n    uint256 yAbs;\\n    unchecked {\\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\\n    }\\n\\n    // Compute the absolute value (x*y\\u00f7UNIT). The resulting value must fit in SD59x18.\\n    uint256 resultAbs = Common.mulDiv18(xAbs, yAbs);\\n    if (resultAbs > uint256(uMAX_SD59x18)) {\\n        revert Errors.PRBMath_SD59x18_Mul_Overflow(x, y);\\n    }\\n\\n    // Check if x and y have the same sign using two's complement representation. The left-most bit represents the sign (1 for\\n    // negative, 0 for positive or zero).\\n    bool sameSign = (xInt ^ yInt) > -1;\\n\\n    // If the inputs have the same sign, the result should be positive. Otherwise, it should be negative.\\n    unchecked {\\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\\n    }\\n}\\n\\n/// @notice Raises x to the power of y using the following formula:\\n///\\n/// $$\\n/// x^y = 2^{log_2{x} * y}\\n/// $$\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {exp2}, {log2}, and {mul}.\\n/// - Returns `UNIT` for 0^0.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {exp2}, {log2}, and {mul}.\\n///\\n/// @param x The base as an SD59x18 number.\\n/// @param y Exponent to raise x to, as an SD59x18 number\\n/// @return result x raised to power y, as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction pow(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    int256 yInt = y.unwrap();\\n\\n    // If both x and y are zero, the result is `UNIT`. If just x is zero, the result is always zero.\\n    if (xInt == 0) {\\n        return yInt == 0 ? UNIT : ZERO;\\n    }\\n    // If x is `UNIT`, the result is always `UNIT`.\\n    else if (xInt == uUNIT) {\\n        return UNIT;\\n    }\\n\\n    // If y is zero, the result is always `UNIT`.\\n    if (yInt == 0) {\\n        return UNIT;\\n    }\\n    // If y is `UNIT`, the result is always x.\\n    else if (yInt == uUNIT) {\\n        return x;\\n    }\\n\\n    // Calculate the result using the formula.\\n    result = exp2(mul(log2(x), y));\\n}\\n\\n/// @notice Raises x (an SD59x18 number) to the power y (an unsigned basic integer) using the well-known\\n/// algorithm \\\"exponentiation by squaring\\\".\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring.\\n///\\n/// Notes:\\n/// - Refer to the notes in {Common.mulDiv18}.\\n/// - Returns `UNIT` for 0^0.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {abs} and {Common.mulDiv18}.\\n/// - The result must fit in SD59x18.\\n///\\n/// @param x The base as an SD59x18 number.\\n/// @param y The exponent as a uint256.\\n/// @return result The result as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction powu(SD59x18 x, uint256 y) pure returns (SD59x18 result) {\\n    uint256 xAbs = uint256(abs(x).unwrap());\\n\\n    // Calculate the first iteration of the loop in advance.\\n    uint256 resultAbs = y & 1 > 0 ? xAbs : uint256(uUNIT);\\n\\n    // Equivalent to `for(y /= 2; y > 0; y /= 2)`.\\n    uint256 yAux = y;\\n    for (yAux >>= 1; yAux > 0; yAux >>= 1) {\\n        xAbs = Common.mulDiv18(xAbs, xAbs);\\n\\n        // Equivalent to `y % 2 == 1`.\\n        if (yAux & 1 > 0) {\\n            resultAbs = Common.mulDiv18(resultAbs, xAbs);\\n        }\\n    }\\n\\n    // The result must fit in SD59x18.\\n    if (resultAbs > uint256(uMAX_SD59x18)) {\\n        revert Errors.PRBMath_SD59x18_Powu_Overflow(x, y);\\n    }\\n\\n    unchecked {\\n        // Is the base negative and the exponent odd? If yes, the result should be negative.\\n        int256 resultInt = int256(resultAbs);\\n        bool isNegative = x.unwrap() < 0 && y & 1 == 1;\\n        if (isNegative) {\\n            resultInt = -resultInt;\\n        }\\n        result = wrap(resultInt);\\n    }\\n}\\n\\n/// @notice Calculates the square root of x using the Babylonian method.\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n///\\n/// Notes:\\n/// - Only the positive root is returned.\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - x cannot be negative, since complex numbers are not supported.\\n/// - x must be less than `MAX_SD59x18 / UNIT`.\\n///\\n/// @param x The SD59x18 number for which to calculate the square root.\\n/// @return result The result as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction sqrt(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt < 0) {\\n        revert Errors.PRBMath_SD59x18_Sqrt_NegativeInput(x);\\n    }\\n    if (xInt > uMAX_SD59x18 / uUNIT) {\\n        revert Errors.PRBMath_SD59x18_Sqrt_Overflow(x);\\n    }\\n\\n    unchecked {\\n        // Multiply x by `UNIT` to account for the factor of `UNIT` picked up when multiplying two SD59x18 numbers.\\n        // In this case, the two numbers are both the square root.\\n        uint256 resultUint = Common.sqrt(uint256(xInt * uUNIT));\\n        result = wrap(int256(resultUint));\\n    }\\n}\\n\",\"keccak256\":\"0xedd0635769176ab99878a91ce267cee2ca107b30e6b0db10736573ff4d102868\",\"license\":\"MIT\"},\"@prb/math/src/sd59x18/ValueType.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"./Casting.sol\\\" as Casting;\\nimport \\\"./Helpers.sol\\\" as Helpers;\\nimport \\\"./Math.sol\\\" as Math;\\n\\n/// @notice The signed 59.18-decimal fixed-point number representation, which can have up to 59 digits and up to 18\\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\\n/// type int256.\\ntype SD59x18 is int256;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CASTING\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    Casting.intoInt256,\\n    Casting.intoSD1x18,\\n    Casting.intoUD2x18,\\n    Casting.intoUD60x18,\\n    Casting.intoUint256,\\n    Casting.intoUint128,\\n    Casting.intoUint40,\\n    Casting.unwrap\\n} for SD59x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            MATHEMATICAL FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    Math.abs,\\n    Math.avg,\\n    Math.ceil,\\n    Math.div,\\n    Math.exp,\\n    Math.exp2,\\n    Math.floor,\\n    Math.frac,\\n    Math.gm,\\n    Math.inv,\\n    Math.log10,\\n    Math.log2,\\n    Math.ln,\\n    Math.mul,\\n    Math.pow,\\n    Math.powu,\\n    Math.sqrt\\n} for SD59x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                HELPER FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    Helpers.add,\\n    Helpers.and,\\n    Helpers.eq,\\n    Helpers.gt,\\n    Helpers.gte,\\n    Helpers.isZero,\\n    Helpers.lshift,\\n    Helpers.lt,\\n    Helpers.lte,\\n    Helpers.mod,\\n    Helpers.neq,\\n    Helpers.not,\\n    Helpers.or,\\n    Helpers.rshift,\\n    Helpers.sub,\\n    Helpers.uncheckedAdd,\\n    Helpers.uncheckedSub,\\n    Helpers.uncheckedUnary,\\n    Helpers.xor\\n} for SD59x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    OPERATORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n// The global \\\"using for\\\" directive makes it possible to use these operators on the SD59x18 type.\\nusing {\\n    Helpers.add as +,\\n    Helpers.and2 as &,\\n    Math.div as /,\\n    Helpers.eq as ==,\\n    Helpers.gt as >,\\n    Helpers.gte as >=,\\n    Helpers.lt as <,\\n    Helpers.lte as <=,\\n    Helpers.mod as %,\\n    Math.mul as *,\\n    Helpers.neq as !=,\\n    Helpers.not as ~,\\n    Helpers.or as |,\\n    Helpers.sub as -,\\n    Helpers.unary as -,\\n    Helpers.xor as ^\\n} for SD59x18 global;\\n\",\"keccak256\":\"0xe03112d145dcd5863aff24e5f381debaae29d446acd5666f3d640e3d9af738d7\",\"license\":\"MIT\"},\"@prb/math/src/ud2x18/Casting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"../Common.sol\\\" as Common;\\nimport \\\"./Errors.sol\\\" as Errors;\\nimport { uMAX_SD1x18 } from \\\"../sd1x18/Constants.sol\\\";\\nimport { SD1x18 } from \\\"../sd1x18/ValueType.sol\\\";\\nimport { SD59x18 } from \\\"../sd59x18/ValueType.sol\\\";\\nimport { UD60x18 } from \\\"../ud60x18/ValueType.sol\\\";\\nimport { UD2x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Casts a UD2x18 number into SD1x18.\\n/// - x must be less than or equal to `uMAX_SD1x18`.\\nfunction intoSD1x18(UD2x18 x) pure returns (SD1x18 result) {\\n    uint64 xUint = UD2x18.unwrap(x);\\n    if (xUint > uint64(uMAX_SD1x18)) {\\n        revert Errors.PRBMath_UD2x18_IntoSD1x18_Overflow(x);\\n    }\\n    result = SD1x18.wrap(int64(xUint));\\n}\\n\\n/// @notice Casts a UD2x18 number into SD59x18.\\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of SD59x18.\\nfunction intoSD59x18(UD2x18 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(int256(uint256(UD2x18.unwrap(x))));\\n}\\n\\n/// @notice Casts a UD2x18 number into UD60x18.\\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of UD60x18.\\nfunction intoUD60x18(UD2x18 x) pure returns (UD60x18 result) {\\n    result = UD60x18.wrap(UD2x18.unwrap(x));\\n}\\n\\n/// @notice Casts a UD2x18 number into uint128.\\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of uint128.\\nfunction intoUint128(UD2x18 x) pure returns (uint128 result) {\\n    result = uint128(UD2x18.unwrap(x));\\n}\\n\\n/// @notice Casts a UD2x18 number into uint256.\\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of uint256.\\nfunction intoUint256(UD2x18 x) pure returns (uint256 result) {\\n    result = uint256(UD2x18.unwrap(x));\\n}\\n\\n/// @notice Casts a UD2x18 number into uint40.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `MAX_UINT40`.\\nfunction intoUint40(UD2x18 x) pure returns (uint40 result) {\\n    uint64 xUint = UD2x18.unwrap(x);\\n    if (xUint > uint64(Common.MAX_UINT40)) {\\n        revert Errors.PRBMath_UD2x18_IntoUint40_Overflow(x);\\n    }\\n    result = uint40(xUint);\\n}\\n\\n/// @notice Alias for {wrap}.\\nfunction ud2x18(uint64 x) pure returns (UD2x18 result) {\\n    result = UD2x18.wrap(x);\\n}\\n\\n/// @notice Unwrap a UD2x18 number into uint64.\\nfunction unwrap(UD2x18 x) pure returns (uint64 result) {\\n    result = UD2x18.unwrap(x);\\n}\\n\\n/// @notice Wraps a uint64 number into UD2x18.\\nfunction wrap(uint64 x) pure returns (UD2x18 result) {\\n    result = UD2x18.wrap(x);\\n}\\n\",\"keccak256\":\"0x9b1a35d432ef951a415fae8098b3c609a99b630a3d5464b3c8e1efa8893eea07\",\"license\":\"MIT\"},\"@prb/math/src/ud2x18/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { UD2x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @dev Euler's number as a UD2x18 number.\\nUD2x18 constant E = UD2x18.wrap(2_718281828459045235);\\n\\n/// @dev The maximum value a UD2x18 number can have.\\nuint64 constant uMAX_UD2x18 = 18_446744073709551615;\\nUD2x18 constant MAX_UD2x18 = UD2x18.wrap(uMAX_UD2x18);\\n\\n/// @dev PI as a UD2x18 number.\\nUD2x18 constant PI = UD2x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit number, which gives the decimal precision of UD2x18.\\nuint256 constant uUNIT = 1e18;\\nUD2x18 constant UNIT = UD2x18.wrap(1e18);\\n\",\"keccak256\":\"0xbd11da8ad79ffc8b7b8244c82632b0ca31970e190a8877ba1a69b4b8065dcea5\",\"license\":\"MIT\"},\"@prb/math/src/ud2x18/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { UD2x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Thrown when trying to cast a UD2x18 number that doesn't fit in SD1x18.\\nerror PRBMath_UD2x18_IntoSD1x18_Overflow(UD2x18 x);\\n\\n/// @notice Thrown when trying to cast a UD2x18 number that doesn't fit in uint40.\\nerror PRBMath_UD2x18_IntoUint40_Overflow(UD2x18 x);\\n\",\"keccak256\":\"0xdf1e22f0b4c8032bcc8b7f63fe3984e1387f3dc7b2e9ab381822249f75376d33\",\"license\":\"MIT\"},\"@prb/math/src/ud2x18/ValueType.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"./Casting.sol\\\" as Casting;\\n\\n/// @notice The unsigned 2.18-decimal fixed-point number representation, which can have up to 2 digits and up to 18\\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\\n/// type uint64. This is useful when end users want to use uint64 to save gas, e.g. with tight variable packing in contract\\n/// storage.\\ntype UD2x18 is uint64;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CASTING\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    Casting.intoSD1x18,\\n    Casting.intoSD59x18,\\n    Casting.intoUD60x18,\\n    Casting.intoUint256,\\n    Casting.intoUint128,\\n    Casting.intoUint40,\\n    Casting.unwrap\\n} for UD2x18 global;\\n\",\"keccak256\":\"0x2802edc9869db116a0b5c490cc5f8554742f747183fa30ac5e9c80bb967e61a1\",\"license\":\"MIT\"},\"@prb/math/src/ud60x18/Casting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"./Errors.sol\\\" as CastingErrors;\\nimport { MAX_UINT128, MAX_UINT40 } from \\\"../Common.sol\\\";\\nimport { uMAX_SD1x18 } from \\\"../sd1x18/Constants.sol\\\";\\nimport { SD1x18 } from \\\"../sd1x18/ValueType.sol\\\";\\nimport { uMAX_SD59x18 } from \\\"../sd59x18/Constants.sol\\\";\\nimport { SD59x18 } from \\\"../sd59x18/ValueType.sol\\\";\\nimport { uMAX_UD2x18 } from \\\"../ud2x18/Constants.sol\\\";\\nimport { UD2x18 } from \\\"../ud2x18/ValueType.sol\\\";\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Casts a UD60x18 number into SD1x18.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `uMAX_SD1x18`.\\nfunction intoSD1x18(UD60x18 x) pure returns (SD1x18 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > uint256(int256(uMAX_SD1x18))) {\\n        revert CastingErrors.PRBMath_UD60x18_IntoSD1x18_Overflow(x);\\n    }\\n    result = SD1x18.wrap(int64(uint64(xUint)));\\n}\\n\\n/// @notice Casts a UD60x18 number into UD2x18.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `uMAX_UD2x18`.\\nfunction intoUD2x18(UD60x18 x) pure returns (UD2x18 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > uMAX_UD2x18) {\\n        revert CastingErrors.PRBMath_UD60x18_IntoUD2x18_Overflow(x);\\n    }\\n    result = UD2x18.wrap(uint64(xUint));\\n}\\n\\n/// @notice Casts a UD60x18 number into SD59x18.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `uMAX_SD59x18`.\\nfunction intoSD59x18(UD60x18 x) pure returns (SD59x18 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > uint256(uMAX_SD59x18)) {\\n        revert CastingErrors.PRBMath_UD60x18_IntoSD59x18_Overflow(x);\\n    }\\n    result = SD59x18.wrap(int256(xUint));\\n}\\n\\n/// @notice Casts a UD60x18 number into uint128.\\n/// @dev This is basically an alias for {unwrap}.\\nfunction intoUint256(UD60x18 x) pure returns (uint256 result) {\\n    result = UD60x18.unwrap(x);\\n}\\n\\n/// @notice Casts a UD60x18 number into uint128.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `MAX_UINT128`.\\nfunction intoUint128(UD60x18 x) pure returns (uint128 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > MAX_UINT128) {\\n        revert CastingErrors.PRBMath_UD60x18_IntoUint128_Overflow(x);\\n    }\\n    result = uint128(xUint);\\n}\\n\\n/// @notice Casts a UD60x18 number into uint40.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `MAX_UINT40`.\\nfunction intoUint40(UD60x18 x) pure returns (uint40 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > MAX_UINT40) {\\n        revert CastingErrors.PRBMath_UD60x18_IntoUint40_Overflow(x);\\n    }\\n    result = uint40(xUint);\\n}\\n\\n/// @notice Alias for {wrap}.\\nfunction ud(uint256 x) pure returns (UD60x18 result) {\\n    result = UD60x18.wrap(x);\\n}\\n\\n/// @notice Alias for {wrap}.\\nfunction ud60x18(uint256 x) pure returns (UD60x18 result) {\\n    result = UD60x18.wrap(x);\\n}\\n\\n/// @notice Unwraps a UD60x18 number into uint256.\\nfunction unwrap(UD60x18 x) pure returns (uint256 result) {\\n    result = UD60x18.unwrap(x);\\n}\\n\\n/// @notice Wraps a uint256 number into the UD60x18 value type.\\nfunction wrap(uint256 x) pure returns (UD60x18 result) {\\n    result = UD60x18.wrap(x);\\n}\\n\",\"keccak256\":\"0x5bb532da36921cbdac64d1f16de5d366ef1f664502e3b7c07d0ad06917551f85\",\"license\":\"MIT\"},\"@prb/math/src/ud60x18/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n// NOTICE: the \\\"u\\\" prefix stands for \\\"unwrapped\\\".\\n\\n/// @dev Euler's number as a UD60x18 number.\\nUD60x18 constant E = UD60x18.wrap(2_718281828459045235);\\n\\n/// @dev The maximum input permitted in {exp}.\\nuint256 constant uEXP_MAX_INPUT = 133_084258667509499440;\\nUD60x18 constant EXP_MAX_INPUT = UD60x18.wrap(uEXP_MAX_INPUT);\\n\\n/// @dev The maximum input permitted in {exp2}.\\nuint256 constant uEXP2_MAX_INPUT = 192e18 - 1;\\nUD60x18 constant EXP2_MAX_INPUT = UD60x18.wrap(uEXP2_MAX_INPUT);\\n\\n/// @dev Half the UNIT number.\\nuint256 constant uHALF_UNIT = 0.5e18;\\nUD60x18 constant HALF_UNIT = UD60x18.wrap(uHALF_UNIT);\\n\\n/// @dev $log_2(10)$ as a UD60x18 number.\\nuint256 constant uLOG2_10 = 3_321928094887362347;\\nUD60x18 constant LOG2_10 = UD60x18.wrap(uLOG2_10);\\n\\n/// @dev $log_2(e)$ as a UD60x18 number.\\nuint256 constant uLOG2_E = 1_442695040888963407;\\nUD60x18 constant LOG2_E = UD60x18.wrap(uLOG2_E);\\n\\n/// @dev The maximum value a UD60x18 number can have.\\nuint256 constant uMAX_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_584007913129639935;\\nUD60x18 constant MAX_UD60x18 = UD60x18.wrap(uMAX_UD60x18);\\n\\n/// @dev The maximum whole value a UD60x18 number can have.\\nuint256 constant uMAX_WHOLE_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_000000000000000000;\\nUD60x18 constant MAX_WHOLE_UD60x18 = UD60x18.wrap(uMAX_WHOLE_UD60x18);\\n\\n/// @dev PI as a UD60x18 number.\\nUD60x18 constant PI = UD60x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit number, which gives the decimal precision of UD60x18.\\nuint256 constant uUNIT = 1e18;\\nUD60x18 constant UNIT = UD60x18.wrap(uUNIT);\\n\\n/// @dev The unit number squared.\\nuint256 constant uUNIT_SQUARED = 1e36;\\nUD60x18 constant UNIT_SQUARED = UD60x18.wrap(uUNIT_SQUARED);\\n\\n/// @dev Zero as a UD60x18 number.\\nUD60x18 constant ZERO = UD60x18.wrap(0);\\n\",\"keccak256\":\"0x2b80d26153d3fdcfb3a9ca772d9309d31ed1275f5b8b54c3ffb54d3652b37d90\",\"license\":\"MIT\"},\"@prb/math/src/ud60x18/Conversions.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { uMAX_UD60x18, uUNIT } from \\\"./Constants.sol\\\";\\nimport { PRBMath_UD60x18_Convert_Overflow } from \\\"./Errors.sol\\\";\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Converts a UD60x18 number to a simple integer by dividing it by `UNIT`.\\n/// @dev The result is rounded toward zero.\\n/// @param x The UD60x18 number to convert.\\n/// @return result The same number in basic integer form.\\nfunction convert(UD60x18 x) pure returns (uint256 result) {\\n    result = UD60x18.unwrap(x) / uUNIT;\\n}\\n\\n/// @notice Converts a simple integer to UD60x18 by multiplying it by `UNIT`.\\n///\\n/// @dev Requirements:\\n/// - x must be less than or equal to `MAX_UD60x18 / UNIT`.\\n///\\n/// @param x The basic integer to convert.\\n/// @param result The same number converted to UD60x18.\\nfunction convert(uint256 x) pure returns (UD60x18 result) {\\n    if (x > uMAX_UD60x18 / uUNIT) {\\n        revert PRBMath_UD60x18_Convert_Overflow(x);\\n    }\\n    unchecked {\\n        result = UD60x18.wrap(x * uUNIT);\\n    }\\n}\\n\",\"keccak256\":\"0xaf7fc2523413822de3b66ba339fe2884fb3b8c6f6cf38ec90a2c3e3aae71df6b\",\"license\":\"MIT\"},\"@prb/math/src/ud60x18/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Thrown when ceiling a number overflows UD60x18.\\nerror PRBMath_UD60x18_Ceil_Overflow(UD60x18 x);\\n\\n/// @notice Thrown when converting a basic integer to the fixed-point format overflows UD60x18.\\nerror PRBMath_UD60x18_Convert_Overflow(uint256 x);\\n\\n/// @notice Thrown when taking the natural exponent of a base greater than 133_084258667509499441.\\nerror PRBMath_UD60x18_Exp_InputTooBig(UD60x18 x);\\n\\n/// @notice Thrown when taking the binary exponent of a base greater than 192e18.\\nerror PRBMath_UD60x18_Exp2_InputTooBig(UD60x18 x);\\n\\n/// @notice Thrown when taking the geometric mean of two numbers and multiplying them overflows UD60x18.\\nerror PRBMath_UD60x18_Gm_Overflow(UD60x18 x, UD60x18 y);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD1x18.\\nerror PRBMath_UD60x18_IntoSD1x18_Overflow(UD60x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD59x18.\\nerror PRBMath_UD60x18_IntoSD59x18_Overflow(UD60x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in UD2x18.\\nerror PRBMath_UD60x18_IntoUD2x18_Overflow(UD60x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint128.\\nerror PRBMath_UD60x18_IntoUint128_Overflow(UD60x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint40.\\nerror PRBMath_UD60x18_IntoUint40_Overflow(UD60x18 x);\\n\\n/// @notice Thrown when taking the logarithm of a number less than 1.\\nerror PRBMath_UD60x18_Log_InputTooSmall(UD60x18 x);\\n\\n/// @notice Thrown when calculating the square root overflows UD60x18.\\nerror PRBMath_UD60x18_Sqrt_Overflow(UD60x18 x);\\n\",\"keccak256\":\"0xa8c60d4066248df22c49c882873efbc017344107edabc48c52209abbc39cb1e3\",\"license\":\"MIT\"},\"@prb/math/src/ud60x18/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { wrap } from \\\"./Casting.sol\\\";\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Implements the checked addition operation (+) in the UD60x18 type.\\nfunction add(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() + y.unwrap());\\n}\\n\\n/// @notice Implements the AND (&) bitwise operation in the UD60x18 type.\\nfunction and(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() & bits);\\n}\\n\\n/// @notice Implements the AND (&) bitwise operation in the UD60x18 type.\\nfunction and2(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() & y.unwrap());\\n}\\n\\n/// @notice Implements the equal operation (==) in the UD60x18 type.\\nfunction eq(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = x.unwrap() == y.unwrap();\\n}\\n\\n/// @notice Implements the greater than operation (>) in the UD60x18 type.\\nfunction gt(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = x.unwrap() > y.unwrap();\\n}\\n\\n/// @notice Implements the greater than or equal to operation (>=) in the UD60x18 type.\\nfunction gte(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = x.unwrap() >= y.unwrap();\\n}\\n\\n/// @notice Implements a zero comparison check function in the UD60x18 type.\\nfunction isZero(UD60x18 x) pure returns (bool result) {\\n    // This wouldn't work if x could be negative.\\n    result = x.unwrap() == 0;\\n}\\n\\n/// @notice Implements the left shift operation (<<) in the UD60x18 type.\\nfunction lshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() << bits);\\n}\\n\\n/// @notice Implements the lower than operation (<) in the UD60x18 type.\\nfunction lt(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = x.unwrap() < y.unwrap();\\n}\\n\\n/// @notice Implements the lower than or equal to operation (<=) in the UD60x18 type.\\nfunction lte(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = x.unwrap() <= y.unwrap();\\n}\\n\\n/// @notice Implements the checked modulo operation (%) in the UD60x18 type.\\nfunction mod(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() % y.unwrap());\\n}\\n\\n/// @notice Implements the not equal operation (!=) in the UD60x18 type.\\nfunction neq(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = x.unwrap() != y.unwrap();\\n}\\n\\n/// @notice Implements the NOT (~) bitwise operation in the UD60x18 type.\\nfunction not(UD60x18 x) pure returns (UD60x18 result) {\\n    result = wrap(~x.unwrap());\\n}\\n\\n/// @notice Implements the OR (|) bitwise operation in the UD60x18 type.\\nfunction or(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() | y.unwrap());\\n}\\n\\n/// @notice Implements the right shift operation (>>) in the UD60x18 type.\\nfunction rshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() >> bits);\\n}\\n\\n/// @notice Implements the checked subtraction operation (-) in the UD60x18 type.\\nfunction sub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() - y.unwrap());\\n}\\n\\n/// @notice Implements the unchecked addition operation (+) in the UD60x18 type.\\nfunction uncheckedAdd(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    unchecked {\\n        result = wrap(x.unwrap() + y.unwrap());\\n    }\\n}\\n\\n/// @notice Implements the unchecked subtraction operation (-) in the UD60x18 type.\\nfunction uncheckedSub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    unchecked {\\n        result = wrap(x.unwrap() - y.unwrap());\\n    }\\n}\\n\\n/// @notice Implements the XOR (^) bitwise operation in the UD60x18 type.\\nfunction xor(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() ^ y.unwrap());\\n}\\n\",\"keccak256\":\"0xf5faff881391d2c060029499a666cc5f0bea90a213150bb476fae8f02a5df268\",\"license\":\"MIT\"},\"@prb/math/src/ud60x18/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"../Common.sol\\\" as Common;\\nimport \\\"./Errors.sol\\\" as Errors;\\nimport { wrap } from \\\"./Casting.sol\\\";\\nimport {\\n    uEXP_MAX_INPUT,\\n    uEXP2_MAX_INPUT,\\n    uHALF_UNIT,\\n    uLOG2_10,\\n    uLOG2_E,\\n    uMAX_UD60x18,\\n    uMAX_WHOLE_UD60x18,\\n    UNIT,\\n    uUNIT,\\n    uUNIT_SQUARED,\\n    ZERO\\n} from \\\"./Constants.sol\\\";\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            MATHEMATICAL FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Calculates the arithmetic average of x and y using the following formula:\\n///\\n/// $$\\n/// avg(x, y) = (x & y) + ((xUint ^ yUint) / 2)\\n/// $$\\n///\\n/// In English, this is what this formula does:\\n///\\n/// 1. AND x and y.\\n/// 2. Calculate half of XOR x and y.\\n/// 3. Add the two results together.\\n///\\n/// This technique is known as SWAR, which stands for \\\"SIMD within a register\\\". You can read more about it here:\\n/// https://devblogs.microsoft.com/oldnewthing/20220207-00/?p=106223\\n///\\n/// @dev Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// @param x The first operand as a UD60x18 number.\\n/// @param y The second operand as a UD60x18 number.\\n/// @return result The arithmetic average as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction avg(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n    uint256 yUint = y.unwrap();\\n    unchecked {\\n        result = wrap((xUint & yUint) + ((xUint ^ yUint) >> 1));\\n    }\\n}\\n\\n/// @notice Yields the smallest whole number greater than or equal to x.\\n///\\n/// @dev This is optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional\\n/// counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n///\\n/// Requirements:\\n/// - x must be less than or equal to `MAX_WHOLE_UD60x18`.\\n///\\n/// @param x The UD60x18 number to ceil.\\n/// @param result The smallest whole number greater than or equal to x, as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction ceil(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n    if (xUint > uMAX_WHOLE_UD60x18) {\\n        revert Errors.PRBMath_UD60x18_Ceil_Overflow(x);\\n    }\\n\\n    assembly (\\\"memory-safe\\\") {\\n        // Equivalent to `x % UNIT`.\\n        let remainder := mod(x, uUNIT)\\n\\n        // Equivalent to `UNIT - remainder`.\\n        let delta := sub(uUNIT, remainder)\\n\\n        // Equivalent to `x + remainder > 0 ? delta : 0`.\\n        result := add(x, mul(delta, gt(remainder, 0)))\\n    }\\n}\\n\\n/// @notice Divides two UD60x18 numbers, returning a new UD60x18 number.\\n///\\n/// @dev Uses {Common.mulDiv} to enable overflow-safe multiplication and division.\\n///\\n/// Notes:\\n/// - Refer to the notes in {Common.mulDiv}.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {Common.mulDiv}.\\n///\\n/// @param x The numerator as a UD60x18 number.\\n/// @param y The denominator as a UD60x18 number.\\n/// @param result The quotient as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction div(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(Common.mulDiv(x.unwrap(), uUNIT, y.unwrap()));\\n}\\n\\n/// @notice Calculates the natural exponent of x using the following formula:\\n///\\n/// $$\\n/// e^x = 2^{x * log_2{e}}\\n/// $$\\n///\\n/// @dev Requirements:\\n/// - x must be less than 133_084258667509499441.\\n///\\n/// @param x The exponent as a UD60x18 number.\\n/// @return result The result as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction exp(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n\\n    // This check prevents values greater than 192e18 from being passed to {exp2}.\\n    if (xUint > uEXP_MAX_INPUT) {\\n        revert Errors.PRBMath_UD60x18_Exp_InputTooBig(x);\\n    }\\n\\n    unchecked {\\n        // Inline the fixed-point multiplication to save gas.\\n        uint256 doubleUnitProduct = xUint * uLOG2_E;\\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\\n    }\\n}\\n\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\n///\\n/// @dev See https://ethereum.stackexchange.com/q/79903/24693\\n///\\n/// Requirements:\\n/// - x must be less than 192e18.\\n/// - The result must fit in UD60x18.\\n///\\n/// @param x The exponent as a UD60x18 number.\\n/// @return result The result as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction exp2(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n\\n    // Numbers greater than or equal to 192e18 don't fit in the 192.64-bit format.\\n    if (xUint > uEXP2_MAX_INPUT) {\\n        revert Errors.PRBMath_UD60x18_Exp2_InputTooBig(x);\\n    }\\n\\n    // Convert x to the 192.64-bit fixed-point format.\\n    uint256 x_192x64 = (xUint << 64) / uUNIT;\\n\\n    // Pass x to the {Common.exp2} function, which uses the 192.64-bit fixed-point number representation.\\n    result = wrap(Common.exp2(x_192x64));\\n}\\n\\n/// @notice Yields the greatest whole number less than or equal to x.\\n/// @dev Optimized for fractional value inputs, because every whole value has (1e18 - 1) fractional counterparts.\\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n/// @param x The UD60x18 number to floor.\\n/// @param result The greatest whole number less than or equal to x, as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction floor(UD60x18 x) pure returns (UD60x18 result) {\\n    assembly (\\\"memory-safe\\\") {\\n        // Equivalent to `x % UNIT`.\\n        let remainder := mod(x, uUNIT)\\n\\n        // Equivalent to `x - remainder > 0 ? remainder : 0)`.\\n        result := sub(x, mul(remainder, gt(remainder, 0)))\\n    }\\n}\\n\\n/// @notice Yields the excess beyond the floor of x using the odd function definition.\\n/// @dev See https://en.wikipedia.org/wiki/Fractional_part.\\n/// @param x The UD60x18 number to get the fractional part of.\\n/// @param result The fractional part of x as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction frac(UD60x18 x) pure returns (UD60x18 result) {\\n    assembly (\\\"memory-safe\\\") {\\n        result := mod(x, uUNIT)\\n    }\\n}\\n\\n/// @notice Calculates the geometric mean of x and y, i.e. $\\\\sqrt{x * y}$, rounding down.\\n///\\n/// @dev Requirements:\\n/// - x * y must fit in UD60x18.\\n///\\n/// @param x The first operand as a UD60x18 number.\\n/// @param y The second operand as a UD60x18 number.\\n/// @return result The result as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction gm(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n    uint256 yUint = y.unwrap();\\n    if (xUint == 0 || yUint == 0) {\\n        return ZERO;\\n    }\\n\\n    unchecked {\\n        // Checking for overflow this way is faster than letting Solidity do it.\\n        uint256 xyUint = xUint * yUint;\\n        if (xyUint / xUint != yUint) {\\n            revert Errors.PRBMath_UD60x18_Gm_Overflow(x, y);\\n        }\\n\\n        // We don't need to multiply the result by `UNIT` here because the x*y product picked up a factor of `UNIT`\\n        // during multiplication. See the comments in {Common.sqrt}.\\n        result = wrap(Common.sqrt(xyUint));\\n    }\\n}\\n\\n/// @notice Calculates the inverse of x.\\n///\\n/// @dev Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - x must not be zero.\\n///\\n/// @param x The UD60x18 number for which to calculate the inverse.\\n/// @return result The inverse as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction inv(UD60x18 x) pure returns (UD60x18 result) {\\n    unchecked {\\n        result = wrap(uUNIT_SQUARED / x.unwrap());\\n    }\\n}\\n\\n/// @notice Calculates the natural logarithm of x using the following formula:\\n///\\n/// $$\\n/// ln{x} = log_2{x} / log_2{e}\\n/// $$\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {log2}.\\n/// - The precision isn't sufficiently fine-grained to return exactly `UNIT` when the input is `E`.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {log2}.\\n///\\n/// @param x The UD60x18 number for which to calculate the natural logarithm.\\n/// @return result The natural logarithm as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction ln(UD60x18 x) pure returns (UD60x18 result) {\\n    unchecked {\\n        // Inline the fixed-point multiplication to save gas. This is overflow-safe because the maximum value that\\n        // {log2} can return is ~196_205294292027477728.\\n        result = wrap(log2(x).unwrap() * uUNIT / uLOG2_E);\\n    }\\n}\\n\\n/// @notice Calculates the common logarithm of x using the following formula:\\n///\\n/// $$\\n/// log_{10}{x} = log_2{x} / log_2{10}\\n/// $$\\n///\\n/// However, if x is an exact power of ten, a hard coded value is returned.\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {log2}.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {log2}.\\n///\\n/// @param x The UD60x18 number for which to calculate the common logarithm.\\n/// @return result The common logarithm as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction log10(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n    if (xUint < uUNIT) {\\n        revert Errors.PRBMath_UD60x18_Log_InputTooSmall(x);\\n    }\\n\\n    // Note that the `mul` in this assembly block is the standard multiplication operation, not {UD60x18.mul}.\\n    // prettier-ignore\\n    assembly (\\\"memory-safe\\\") {\\n        switch x\\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\\n        case 1000000000000000000 { result := 0 }\\n        case 10000000000000000000 { result := uUNIT }\\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 59) }\\n        default { result := uMAX_UD60x18 }\\n    }\\n\\n    if (result.unwrap() == uMAX_UD60x18) {\\n        unchecked {\\n            // Inline the fixed-point division to save gas.\\n            result = wrap(log2(x).unwrap() * uUNIT / uLOG2_10);\\n        }\\n    }\\n}\\n\\n/// @notice Calculates the binary logarithm of x using the iterative approximation algorithm:\\n///\\n/// $$\\n/// log_2{x} = n + log_2{y}, \\\\text{ where } y = x*2^{-n}, \\\\ y \\\\in [1, 2)\\n/// $$\\n///\\n/// For $0 \\\\leq x \\\\lt 1$, the input is inverted:\\n///\\n/// $$\\n/// log_2{x} = -log_2{\\\\frac{1}{x}}\\n/// $$\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n///\\n/// Notes:\\n/// - Due to the lossy precision of the iterative approximation, the results are not perfectly accurate to the last decimal.\\n///\\n/// Requirements:\\n/// - x must be greater than zero.\\n///\\n/// @param x The UD60x18 number for which to calculate the binary logarithm.\\n/// @return result The binary logarithm as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction log2(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n\\n    if (xUint < uUNIT) {\\n        revert Errors.PRBMath_UD60x18_Log_InputTooSmall(x);\\n    }\\n\\n    unchecked {\\n        // Calculate the integer part of the logarithm.\\n        uint256 n = Common.msb(xUint / uUNIT);\\n\\n        // This is the integer part of the logarithm as a UD60x18 number. The operation can't overflow because n\\n        // n is at most 255 and UNIT is 1e18.\\n        uint256 resultUint = n * uUNIT;\\n\\n        // Calculate $y = x * 2^{-n}$.\\n        uint256 y = xUint >> n;\\n\\n        // If y is the unit number, the fractional part is zero.\\n        if (y == uUNIT) {\\n            return wrap(resultUint);\\n        }\\n\\n        // Calculate the fractional part via the iterative approximation.\\n        // The `delta >>= 1` part is equivalent to `delta /= 2`, but shifting bits is more gas efficient.\\n        uint256 DOUBLE_UNIT = 2e18;\\n        for (uint256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\\n            y = (y * y) / uUNIT;\\n\\n            // Is y^2 >= 2e18 and so in the range [2e18, 4e18)?\\n            if (y >= DOUBLE_UNIT) {\\n                // Add the 2^{-m} factor to the logarithm.\\n                resultUint += delta;\\n\\n                // Halve y, which corresponds to z/2 in the Wikipedia article.\\n                y >>= 1;\\n            }\\n        }\\n        result = wrap(resultUint);\\n    }\\n}\\n\\n/// @notice Multiplies two UD60x18 numbers together, returning a new UD60x18 number.\\n///\\n/// @dev Uses {Common.mulDiv} to enable overflow-safe multiplication and division.\\n///\\n/// Notes:\\n/// - Refer to the notes in {Common.mulDiv}.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {Common.mulDiv}.\\n///\\n/// @dev See the documentation in {Common.mulDiv18}.\\n/// @param x The multiplicand as a UD60x18 number.\\n/// @param y The multiplier as a UD60x18 number.\\n/// @return result The product as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mul(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(Common.mulDiv18(x.unwrap(), y.unwrap()));\\n}\\n\\n/// @notice Raises x to the power of y.\\n///\\n/// For $1 \\\\leq x \\\\leq \\\\infty$, the following standard formula is used:\\n///\\n/// $$\\n/// x^y = 2^{log_2{x} * y}\\n/// $$\\n///\\n/// For $0 \\\\leq x \\\\lt 1$, since the unsigned {log2} is undefined, an equivalent formula is used:\\n///\\n/// $$\\n/// i = \\\\frac{1}{x}\\n/// w = 2^{log_2{i} * y}\\n/// x^y = \\\\frac{1}{w}\\n/// $$\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {log2} and {mul}.\\n/// - Returns `UNIT` for 0^0.\\n/// - It may not perform well with very small values of x. Consider using SD59x18 as an alternative.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {exp2}, {log2}, and {mul}.\\n///\\n/// @param x The base as a UD60x18 number.\\n/// @param y The exponent as a UD60x18 number.\\n/// @return result The result as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction pow(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n    uint256 yUint = y.unwrap();\\n\\n    // If both x and y are zero, the result is `UNIT`. If just x is zero, the result is always zero.\\n    if (xUint == 0) {\\n        return yUint == 0 ? UNIT : ZERO;\\n    }\\n    // If x is `UNIT`, the result is always `UNIT`.\\n    else if (xUint == uUNIT) {\\n        return UNIT;\\n    }\\n\\n    // If y is zero, the result is always `UNIT`.\\n    if (yUint == 0) {\\n        return UNIT;\\n    }\\n    // If y is `UNIT`, the result is always x.\\n    else if (yUint == uUNIT) {\\n        return x;\\n    }\\n\\n    // If x is greater than `UNIT`, use the standard formula.\\n    if (xUint > uUNIT) {\\n        result = exp2(mul(log2(x), y));\\n    }\\n    // Conversely, if x is less than `UNIT`, use the equivalent formula.\\n    else {\\n        UD60x18 i = wrap(uUNIT_SQUARED / xUint);\\n        UD60x18 w = exp2(mul(log2(i), y));\\n        result = wrap(uUNIT_SQUARED / w.unwrap());\\n    }\\n}\\n\\n/// @notice Raises x (a UD60x18 number) to the power y (an unsigned basic integer) using the well-known\\n/// algorithm \\\"exponentiation by squaring\\\".\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring.\\n///\\n/// Notes:\\n/// - Refer to the notes in {Common.mulDiv18}.\\n/// - Returns `UNIT` for 0^0.\\n///\\n/// Requirements:\\n/// - The result must fit in UD60x18.\\n///\\n/// @param x The base as a UD60x18 number.\\n/// @param y The exponent as a uint256.\\n/// @return result The result as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction powu(UD60x18 x, uint256 y) pure returns (UD60x18 result) {\\n    // Calculate the first iteration of the loop in advance.\\n    uint256 xUint = x.unwrap();\\n    uint256 resultUint = y & 1 > 0 ? xUint : uUNIT;\\n\\n    // Equivalent to `for(y /= 2; y > 0; y /= 2)`.\\n    for (y >>= 1; y > 0; y >>= 1) {\\n        xUint = Common.mulDiv18(xUint, xUint);\\n\\n        // Equivalent to `y % 2 == 1`.\\n        if (y & 1 > 0) {\\n            resultUint = Common.mulDiv18(resultUint, xUint);\\n        }\\n    }\\n    result = wrap(resultUint);\\n}\\n\\n/// @notice Calculates the square root of x using the Babylonian method.\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n///\\n/// Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - x must be less than `MAX_UD60x18 / UNIT`.\\n///\\n/// @param x The UD60x18 number for which to calculate the square root.\\n/// @return result The result as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction sqrt(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n\\n    unchecked {\\n        if (xUint > uMAX_UD60x18 / uUNIT) {\\n            revert Errors.PRBMath_UD60x18_Sqrt_Overflow(x);\\n        }\\n        // Multiply x by `UNIT` to account for the factor of `UNIT` picked up when multiplying two UD60x18 numbers.\\n        // In this case, the two numbers are both the square root.\\n        result = wrap(Common.sqrt(xUint * uUNIT));\\n    }\\n}\\n\",\"keccak256\":\"0x462144667aac3f96d5f8dba7aa68fe4c5a3f61e1d7bbbc81bee21168817f9c09\",\"license\":\"MIT\"},\"@prb/math/src/ud60x18/ValueType.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"./Casting.sol\\\" as Casting;\\nimport \\\"./Helpers.sol\\\" as Helpers;\\nimport \\\"./Math.sol\\\" as Math;\\n\\n/// @notice The unsigned 60.18-decimal fixed-point number representation, which can have up to 60 digits and up to 18\\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the Solidity type uint256.\\n/// @dev The value type is defined here so it can be imported in all other files.\\ntype UD60x18 is uint256;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CASTING\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    Casting.intoSD1x18,\\n    Casting.intoUD2x18,\\n    Casting.intoSD59x18,\\n    Casting.intoUint128,\\n    Casting.intoUint256,\\n    Casting.intoUint40,\\n    Casting.unwrap\\n} for UD60x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            MATHEMATICAL FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n// The global \\\"using for\\\" directive makes the functions in this library callable on the UD60x18 type.\\nusing {\\n    Math.avg,\\n    Math.ceil,\\n    Math.div,\\n    Math.exp,\\n    Math.exp2,\\n    Math.floor,\\n    Math.frac,\\n    Math.gm,\\n    Math.inv,\\n    Math.ln,\\n    Math.log10,\\n    Math.log2,\\n    Math.mul,\\n    Math.pow,\\n    Math.powu,\\n    Math.sqrt\\n} for UD60x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                HELPER FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n// The global \\\"using for\\\" directive makes the functions in this library callable on the UD60x18 type.\\nusing {\\n    Helpers.add,\\n    Helpers.and,\\n    Helpers.eq,\\n    Helpers.gt,\\n    Helpers.gte,\\n    Helpers.isZero,\\n    Helpers.lshift,\\n    Helpers.lt,\\n    Helpers.lte,\\n    Helpers.mod,\\n    Helpers.neq,\\n    Helpers.not,\\n    Helpers.or,\\n    Helpers.rshift,\\n    Helpers.sub,\\n    Helpers.uncheckedAdd,\\n    Helpers.uncheckedSub,\\n    Helpers.xor\\n} for UD60x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    OPERATORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n// The global \\\"using for\\\" directive makes it possible to use these operators on the UD60x18 type.\\nusing {\\n    Helpers.add as +,\\n    Helpers.and2 as &,\\n    Math.div as /,\\n    Helpers.eq as ==,\\n    Helpers.gt as >,\\n    Helpers.gte as >=,\\n    Helpers.lt as <,\\n    Helpers.lte as <=,\\n    Helpers.or as |,\\n    Helpers.mod as %,\\n    Math.mul as *,\\n    Helpers.neq as !=,\\n    Helpers.not as ~,\\n    Helpers.sub as -,\\n    Helpers.xor as ^\\n} for UD60x18 global;\\n\",\"keccak256\":\"0xdd873b5124180d9b71498b3a7fe93b1c08c368bec741f7d5f8e17f78a0b70f31\",\"license\":\"MIT\"},\"contracts/tokens/PenXKey.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\\\";\\nimport { UD60x18, ud, add, mul, ln, unwrap } from \\\"@prb/math/src/UD60x18.sol\\\";\\n\\ncontract PenXKey is ERC721, ERC721URIStorage, ERC721Enumerable, ERC721Burnable, Ownable {\\n  uint256 public _maxTokenId = 0;\\n\\n  string public baseURI;\\n\\n  event NFTMinted(address indexed owner, uint256 indexed tokenId);\\n\\n  constructor(address initialOwner, string memory _baseURI) ERC721(\\\"PenX Key\\\", \\\"PXK\\\") Ownable(initialOwner) {\\n    baseURI = _baseURI;\\n  }\\n\\n  function mintKey() external payable {\\n    _mintNFT();\\n  }\\n\\n  function burnKey(uint256 amount) external {\\n    uint256 balance = balanceOf(msg.sender);\\n    require(amount <= balance, \\\"Key balance not enough\\\");\\n\\n    for (uint256 i = 0; i < amount; i++) {\\n      // console.log(\\\"====getBurnPrice():\\\", getBurnPrice());\\n      _safeTransferETH(msg.sender, getBurnPrice());\\n      uint256 tokenId = tokenOfOwnerByIndex(msg.sender, i);\\n      _burn(tokenId);\\n    }\\n  }\\n\\n  function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {\\n    return super.tokenURI(tokenId);\\n  }\\n\\n  function getPrice(uint256 x) public pure returns (uint256) {\\n    return _calculatePrice(x);\\n  }\\n\\n  function getMintPrice() public view returns (uint256) {\\n    return _calculatePrice(totalSupply() + 1);\\n  }\\n\\n  function getBurnPrice() public view returns (uint256) {\\n    return _calculatePrice(totalSupply() - 1);\\n  }\\n\\n  function maxTokenId() public view returns (uint256) {\\n    return _maxTokenId;\\n  }\\n\\n  function getBalance() public view returns (uint) {\\n    return address(this).balance;\\n  }\\n\\n  function _getTokenURI(uint256 tokenId) internal view returns (string memory) {\\n    string memory postfix = \\\".json\\\";\\n    return string(abi.encodePacked(baseURI, Strings.toString(uint256(tokenId)), postfix));\\n  }\\n\\n  function _mintNFT() internal {\\n    require(msg.value >= getMintPrice(), \\\"Insufficient payment\\\");\\n\\n    // console.log(\\\"===getMintPrice():\\\", getMintPrice());\\n\\n    uint256 tokenId = _maxTokenId;\\n    string memory uri = _getTokenURI(tokenId);\\n\\n    _safeMint(msg.sender, tokenId);\\n    _setTokenURI(tokenId, uri);\\n\\n    _maxTokenId++;\\n    emit NFTMinted(msg.sender, tokenId);\\n  }\\n\\n  /**\\n   * P(y)= 0.2 * ln(0.01 * x + 1) + 0.1\\n   *\\n   * @param x totalSupply\\n   */\\n  function _calculatePrice(uint256 x) internal pure returns (uint256) {\\n    // Convert constants to 60.18-decimal fixed-point format\\n    uint256 constant1 = 2 * 10 ** 17;\\n    uint256 constant2 = 1 * 10 ** 17;\\n    uint256 factor = 0.01 * 10 ** 18; // 0.01 in 60.18-decimal fixed-point format\\n\\n    // Calculate the argument for the natural logarithm\\n    UD60x18 argument = ud(factor * x + 10 ** 18); // 1 in 60.18-decimal fixed-point format\\n\\n    // Calculate the natural logarithm\\n    UD60x18 lnValue = ln(argument);\\n\\n    // Calculate the final price\\n    UD60x18 result = ud(constant1) * lnValue + ud(constant2);\\n\\n    return result.unwrap();\\n  }\\n\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public view override(ERC721, ERC721URIStorage, ERC721Enumerable) returns (bool) {\\n    return super.supportsInterface(interfaceId);\\n  }\\n\\n  function _update(\\n    address to,\\n    uint256 tokenId,\\n    address auth\\n  ) internal override(ERC721, ERC721Enumerable) returns (address) {\\n    return super._update(to, tokenId, auth);\\n  }\\n\\n  function _increaseBalance(address account, uint128 value) internal override(ERC721, ERC721Enumerable) {\\n    super._increaseBalance(account, value);\\n  }\\n\\n  /**\\n   * @notice Transfers ETH to the recipient address\\n   * @param to The destination of the transfer\\n   * @param value The value to be transferred\\n   * @dev Fails with `ETH transfer failed`\\n   */\\n  function _safeTransferETH(address to, uint256 value) internal {\\n    if (value > 0) {\\n      (bool success, ) = to.call{ value: value }(new bytes(0));\\n      require(success, \\\"ETH transfer failed\\\");\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x2fc79cc7d9e8b0ffcfaa2ab3c3650e0c219d850b92204c215d8eb2b16821808b\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040526000600c553480156200001657600080fd5b5060405162002e1838038062002e18833981016040819052620000399162000154565b816040518060400160405280600881526020016750656e58204b657960c01b8152506040518060400160405280600381526020016250584b60e81b8152508160009081620000889190620002d9565b506001620000978282620002d9565b5050506001600160a01b038116620000c957604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b620000d481620000ec565b50600d620000e38282620002d9565b505050620003a5565b600b80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b634e487b7160e01b600052604160045260246000fd5b600080604083850312156200016857600080fd5b82516001600160a01b03811681146200018057600080fd5b602084810151919350906001600160401b0380821115620001a057600080fd5b818601915086601f830112620001b557600080fd5b815181811115620001ca57620001ca6200013e565b604051601f8201601f19908116603f01168101908382118183101715620001f557620001f56200013e565b8160405282815289868487010111156200020e57600080fd5b600093505b8284101562000232578484018601518185018701529285019262000213565b60008684830101528096505050505050509250929050565b600181811c908216806200025f57607f821691505b6020821081036200028057634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115620002d457600081815260208120601f850160051c81016020861015620002af5750805b601f850160051c820191505b81811015620002d057828155600101620002bb565b5050505b505050565b81516001600160401b03811115620002f557620002f56200013e565b6200030d816200030684546200024a565b8462000286565b602080601f8311600181146200034557600084156200032c5750858301515b600019600386901b1c1916600185901b178555620002d0565b600085815260208120601f198616915b82811015620003765788860151825594840194600190910190840162000355565b5085821015620003955787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b612a6380620003b56000396000f3fe6080604052600436106101c25760003560e01c80636c0360eb116100f757806395d89b4111610095578063c87b56dd11610064578063c87b56dd146104be578063e7572230146104de578063e985e9c5146104fe578063f2fde38b1461055457600080fd5b806395d89b4114610454578063a22cb46514610469578063a7f93ebd14610489578063b88d4fde1461049e57600080fd5b80638da5cb5b116100d15780638da5cb5b146103de57806390901aa31461040957806390d340e11461042957806391ba317a1461043f57600080fd5b80636c0360eb1461039457806370a08231146103a9578063715018a6146103c957600080fd5b80632ae6218d1161016457806342966c681161013e57806342966c681461032c5780634f6ccce71461034c5780636352211e1461036c57806369ebf34e1461038c57600080fd5b80632ae6218d146102d75780632f745c59146102ec57806342842e0e1461030c57600080fd5b8063095ea7b3116101a0578063095ea7b31461026357806312065fe01461028557806318160ddd146102a257806323b872dd146102b757600080fd5b806301ffc9a7146101c757806306fdde03146101fc578063081812fc1461021e575b600080fd5b3480156101d357600080fd5b506101e76101e23660046122e8565b610574565b60405190151581526020015b60405180910390f35b34801561020857600080fd5b50610211610585565b6040516101f39190612373565b34801561022a57600080fd5b5061023e610239366004612386565b610617565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101f3565b34801561026f57600080fd5b5061028361027e3660046123c8565b61064d565b005b34801561029157600080fd5b50475b6040519081526020016101f3565b3480156102ae57600080fd5b50600954610294565b3480156102c357600080fd5b506102836102d23660046123f2565b61065c565b3480156102e357600080fd5b50610294610752565b3480156102f857600080fd5b506102946103073660046123c8565b610776565b34801561031857600080fd5b506102836103273660046123f2565b61080e565b34801561033857600080fd5b50610283610347366004612386565b61082e565b34801561035857600080fd5b50610294610367366004612386565b61083a565b34801561037857600080fd5b5061023e610387366004612386565b6108ac565b6102836108b7565b3480156103a057600080fd5b506102116108c1565b3480156103b557600080fd5b506102946103c436600461242e565b61094f565b3480156103d557600080fd5b506102836109ca565b3480156103ea57600080fd5b50600b5473ffffffffffffffffffffffffffffffffffffffff1661023e565b34801561041557600080fd5b50610283610424366004612386565b6109dc565b34801561043557600080fd5b50610294600c5481565b34801561044b57600080fd5b50600c54610294565b34801561046057600080fd5b50610211610a99565b34801561047557600080fd5b50610283610484366004612449565b610aa8565b34801561049557600080fd5b50610294610ab3565b3480156104aa57600080fd5b506102836104b93660046124b4565b610acc565b3480156104ca57600080fd5b506102116104d9366004612386565b610ae3565b3480156104ea57600080fd5b506102946104f9366004612386565b610aee565b34801561050a57600080fd5b506101e76105193660046125ae565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260056020908152604080832093909416825291909152205460ff1690565b34801561056057600080fd5b5061028361056f36600461242e565b610af9565b600061057f82610b5d565b92915050565b606060008054610594906125e1565b80601f01602080910402602001604051908101604052809291908181526020018280546105c0906125e1565b801561060d5780601f106105e25761010080835404028352916020019161060d565b820191906000526020600020905b8154815290600101906020018083116105f057829003601f168201915b5050505050905090565b600061062282610bb3565b5060008281526004602052604090205473ffffffffffffffffffffffffffffffffffffffff1661057f565b610658828233610c12565b5050565b73ffffffffffffffffffffffffffffffffffffffff82166106b1576040517f64a0ae92000000000000000000000000000000000000000000000000000000008152600060048201526024015b60405180910390fd5b60006106be838333610c1f565b90508373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161461074c576040517f64283d7b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808616600483015260248201849052821660448201526064016106a8565b50505050565b6000610771600161076260095490565b61076c9190612663565b610c34565b905090565b60006107818361094f565b82106107d8576040517fa57d13dc00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152602481018390526044016106a8565b5073ffffffffffffffffffffffffffffffffffffffff919091166000908152600760209081526040808320938352929052205490565b61082983838360405180602001604052806000815250610acc565b505050565b61065860008233610c1f565b600061084560095490565b8210610887576040517fa57d13dc00000000000000000000000000000000000000000000000000000000815260006004820152602481018390526044016106a8565b6009828154811061089a5761089a612676565b90600052602060002001549050919050565b600061057f82610bb3565b6108bf610ca3565b565b600d80546108ce906125e1565b80601f01602080910402602001604051908101604052809291908181526020018280546108fa906125e1565b80156109475780601f1061091c57610100808354040283529160200191610947565b820191906000526020600020905b81548152906001019060200180831161092a57829003601f168201915b505050505081565b600073ffffffffffffffffffffffffffffffffffffffff82166109a1576040517f89c62b64000000000000000000000000000000000000000000000000000000008152600060048201526024016106a8565b5073ffffffffffffffffffffffffffffffffffffffff1660009081526003602052604090205490565b6109d2610d7e565b6108bf6000610dd1565b60006109e73361094f565b905080821115610a53576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4b65792062616c616e6365206e6f7420656e6f7567680000000000000000000060448201526064016106a8565b60005b8281101561082957610a6f33610a6a610752565b610e48565b6000610a7b3383610776565b9050610a8681610f32565b5080610a91816126a5565b915050610a56565b606060018054610594906125e1565b610658338383610f93565b6000610771610ac160095490565b61076c9060016126dd565b610ad784848461065c565b61074c84848484611090565b606061057f82611287565b600061057f82610c34565b610b01610d7e565b73ffffffffffffffffffffffffffffffffffffffff8116610b51576040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600060048201526024016106a8565b610b5a81610dd1565b50565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f780e9d6300000000000000000000000000000000000000000000000000000000148061057f575061057f82611390565b60008181526002602052604081205473ffffffffffffffffffffffffffffffffffffffff168061057f576040517f7e273289000000000000000000000000000000000000000000000000000000008152600481018490526024016106a8565b61082983838360016113e6565b6000610c2c8484846115b1565b949350505050565b60006702c68af0bb14000067016345785d8a0000662386f26fc1000083610c73610c5e87846126f0565b610c7090670de0b6b3a76400006126dd565b90565b90506000610c80826116cc565b90506000610c97610c918784611701565b86611717565b98975050505050505050565b610cab610ab3565b341015610d14576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f496e73756666696369656e74207061796d656e7400000000000000000000000060448201526064016106a8565b600c546000610d2282611726565b9050610d2e3383611792565b610d3882826117ac565b600c8054906000610d48836126a5565b9091555050604051829033907f4cc0a9c4a99ddc700de1af2c9f916a7cbfdb71f14801ccff94061ad1ef8a804090600090a35050565b600b5473ffffffffffffffffffffffffffffffffffffffff1633146108bf576040517f118cdaa70000000000000000000000000000000000000000000000000000000081523360048201526024016106a8565b600b805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b8015610658576040805160008082526020820190925273ffffffffffffffffffffffffffffffffffffffff8416908390604051610e859190612707565b60006040518083038185875af1925050503d8060008114610ec2576040519150601f19603f3d011682016040523d82523d6000602084013e610ec7565b606091505b5050905080610829576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f455448207472616e73666572206661696c65640000000000000000000000000060448201526064016106a8565b6000610f416000836000610c1f565b905073ffffffffffffffffffffffffffffffffffffffff8116610658576040517f7e273289000000000000000000000000000000000000000000000000000000008152600481018390526024016106a8565b73ffffffffffffffffffffffffffffffffffffffff8216610ff8576040517f5b08ba1800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff831660048201526024016106a8565b73ffffffffffffffffffffffffffffffffffffffff83811660008181526005602090815260408083209487168084529482529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b73ffffffffffffffffffffffffffffffffffffffff83163b1561074c576040517f150b7a0200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84169063150b7a0290611105903390889087908790600401612723565b6020604051808303816000875af192505050801561115e575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261115b91810190612762565b60015b6111ed573d80801561118c576040519150601f19603f3d011682016040523d82523d6000602084013e611191565b606091505b5080516000036111e5576040517f64a0ae9200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff851660048201526024016106a8565b805181602001fd5b7fffffffff0000000000000000000000000000000000000000000000000000000081167f150b7a020000000000000000000000000000000000000000000000000000000014611280576040517f64a0ae9200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff851660048201526024016106a8565b5050505050565b606061129282610bb3565b50600082815260066020526040812080546112ac906125e1565b80601f01602080910402602001604051908101604052809291908181526020018280546112d8906125e1565b80156113255780601f106112fa57610100808354040283529160200191611325565b820191906000526020600020905b81548152906001019060200180831161130857829003601f168201915b50505050509050600061134360408051602081019091526000815290565b90508051600003611355575092915050565b81511561138757808260405160200161136f92919061277f565b60405160208183030381529060405292505050919050565b610c2c846117fc565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f4906490600000000000000000000000000000000000000000000000000000000148061057f575061057f8261185a565b8080611407575073ffffffffffffffffffffffffffffffffffffffff821615155b1561155c57600061141784610bb3565b905073ffffffffffffffffffffffffffffffffffffffff83161580159061146a57508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614155b80156114a9575073ffffffffffffffffffffffffffffffffffffffff80821660009081526005602090815260408083209387168352929052205460ff16155b156114f8576040517fa9fbf51f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff841660048201526024016106a8565b811561155a57838573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45b505b5050600090815260046020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b6000806115bf85858561193d565b905073ffffffffffffffffffffffffffffffffffffffff81166116295761162484600980546000838152600a60205260408120829055600182018355919091527f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af0155565b611666565b8473ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614611666576116668185611aba565b73ffffffffffffffffffffffffffffffffffffffff851661168f5761168a84611b65565b610c2c565b8473ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610c2c57610c2c8585611c14565b600061057f6714057b7ef767814f670de0b6b3a76400006116ef610c7086611c71565b02816116fd576116fd6127ae565b0490565b6000611710610c708484611dd7565b9392505050565b6000611710610c7083856126dd565b60408051808201909152600581527f2e6a736f6e0000000000000000000000000000000000000000000000000000006020820152606090600d61176884611ede565b8260405160200161177b939291906127dd565b604051602081830303815290604052915050919050565b610658828260405180602001604052806000815250611f9c565b60008281526006602052604090206117c482826128e4565b506040518281527ff8e1a15aba9398e019f0b49df1a4fde98ee17ae345cb5f6b5e2c27f5033e8ce79060200160405180910390a15050565b606061180782610bb3565b50600061181f60408051602081019091526000815290565b9050600081511161183f5760405180602001604052806000815250611710565b8061184984611ede565b60405160200161177b92919061277f565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f80ac58cd0000000000000000000000000000000000000000000000000000000014806118ed57507fffffffff0000000000000000000000000000000000000000000000000000000082167f5b5e139f00000000000000000000000000000000000000000000000000000000145b8061057f57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff0000000000000000000000000000000000000000000000000000000083161461057f565b60008281526002602052604081205473ffffffffffffffffffffffffffffffffffffffff9081169083161561197757611977818486611fb3565b73ffffffffffffffffffffffffffffffffffffffff8116156119ed576119a16000856000806113e6565b73ffffffffffffffffffffffffffffffffffffffff8116600090815260036020526040902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190555b73ffffffffffffffffffffffffffffffffffffffff851615611a365773ffffffffffffffffffffffffffffffffffffffff85166000908152600360205260409020805460010190555b60008481526002602052604080822080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff89811691821790925591518793918516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4949350505050565b6000611ac58361094f565b600083815260086020526040902054909150808214611b255773ffffffffffffffffffffffffffffffffffffffff841660009081526007602090815260408083208584528252808320548484528184208190558352600890915290208190555b50600091825260086020908152604080842084905573ffffffffffffffffffffffffffffffffffffffff9094168352600781528383209183525290812055565b600954600090611b7790600190612663565b6000838152600a602052604081205460098054939450909284908110611b9f57611b9f612676565b906000526020600020015490508060098381548110611bc057611bc0612676565b6000918252602080832090910192909255828152600a90915260408082208490558582528120556009805480611bf857611bf86129fe565b6001900381819060005260206000200160009055905550505050565b60006001611c218461094f565b611c2b9190612663565b73ffffffffffffffffffffffffffffffffffffffff9093166000908152600760209081526040808320868452825280832085905593825260089052919091209190915550565b600081670de0b6b3a7640000811015611cb9576040517f36d32ef0000000000000000000000000000000000000000000000000000000008152600481018490526024016106a8565b6000611d45670de0b6b3a7640000830460016fffffffffffffffffffffffffffffffff821160071b91821c67ffffffffffffffff811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211871b91821c969096119490961792909217171791909117919091171790565b9050670de0b6b3a7640000810282821c7ffffffffffffffffffffffffffffffffffffffffffffffffff21f494c589c00008101611d8857815b9695505050505050565b671bc16d674ec800006706f05b59d3b200005b8015611dcb57670de0b6b3a7640000838002049250818310611dc3579283019260019290921c915b60011c611d9b565b50919695505050505050565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84860984860292508281108382030391505080600003611e295750670de0b6b3a76400009004905061057f565b670de0b6b3a76400008110611e74576040517f5173648d00000000000000000000000000000000000000000000000000000000815260048101869052602481018590526044016106a8565b6000670de0b6b3a7640000858709620400008185030493109091037d40000000000000000000000000000000000000000000000000000000000002919091177faccb18165bd6fe31ae1cf318dc5b51eee0e1ba569b88cd74c1773b91fac106690291505092915050565b60606000611eeb83612063565b600101905060008167ffffffffffffffff811115611f0b57611f0b612485565b6040519080825280601f01601f191660200182016040528015611f35576020820181803683370190505b5090508181016020015b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff017f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8504945084611f3f57509392505050565b611fa68383612145565b6108296000848484611090565b611fbe8383836121f6565b6108295773ffffffffffffffffffffffffffffffffffffffff8316612012576040517f7e273289000000000000000000000000000000000000000000000000000000008152600481018290526024016106a8565b6040517f177e802f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83166004820152602481018290526044016106a8565b6000807a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106120ac577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000830492506040015b6d04ee2d6d415b85acef810000000083106120d8576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc1000083106120f657662386f26fc10000830492506010015b6305f5e100831061210e576305f5e100830492506008015b612710831061212257612710830492506004015b60648310612134576064830492506002015b600a831061057f5760010192915050565b73ffffffffffffffffffffffffffffffffffffffff8216612195576040517f64a0ae92000000000000000000000000000000000000000000000000000000008152600060048201526024016106a8565b60006121a383836000610c1f565b905073ffffffffffffffffffffffffffffffffffffffff811615610829576040517f73c6ac6e000000000000000000000000000000000000000000000000000000008152600060048201526024016106a8565b600073ffffffffffffffffffffffffffffffffffffffff831615801590610c2c57508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161480612284575073ffffffffffffffffffffffffffffffffffffffff80851660009081526005602090815260408083209387168352929052205460ff165b80610c2c57505060009081526004602052604090205473ffffffffffffffffffffffffffffffffffffffff908116911614919050565b7fffffffff0000000000000000000000000000000000000000000000000000000081168114610b5a57600080fd5b6000602082840312156122fa57600080fd5b8135611710816122ba565b60005b83811015612320578181015183820152602001612308565b50506000910152565b60008151808452612341816020860160208601612305565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006117106020830184612329565b60006020828403121561239857600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff811681146123c357600080fd5b919050565b600080604083850312156123db57600080fd5b6123e48361239f565b946020939093013593505050565b60008060006060848603121561240757600080fd5b6124108461239f565b925061241e6020850161239f565b9150604084013590509250925092565b60006020828403121561244057600080fd5b6117108261239f565b6000806040838503121561245c57600080fd5b6124658361239f565b91506020830135801515811461247a57600080fd5b809150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080600080608085870312156124ca57600080fd5b6124d38561239f565b93506124e16020860161239f565b925060408501359150606085013567ffffffffffffffff8082111561250557600080fd5b818701915087601f83011261251957600080fd5b81358181111561252b5761252b612485565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190838211818310171561257157612571612485565b816040528281528a602084870101111561258a57600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b600080604083850312156125c157600080fd5b6125ca8361239f565b91506125d86020840161239f565b90509250929050565b600181811c908216806125f557607f821691505b60208210810361262e577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8181038181111561057f5761057f612634565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036126d6576126d6612634565b5060010190565b8082018082111561057f5761057f612634565b808202811582820484141761057f5761057f612634565b60008251612719818460208701612305565b9190910192915050565b600073ffffffffffffffffffffffffffffffffffffffff808716835280861660208401525083604083015260806060830152611d7e6080830184612329565b60006020828403121561277457600080fd5b8151611710816122ba565b60008351612791818460208801612305565b8351908301906127a5818360208801612305565b01949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008085546127eb816125e1565b60018281168015612803576001811461283657612865565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0084168752821515830287019450612865565b8960005260208060002060005b8581101561285c5781548a820152908401908201612843565b50505082870194505b505050508451612879818360208901612305565b845191019061288c818360208801612305565b0195945050505050565b601f82111561082957600081815260208120601f850160051c810160208610156128bd5750805b601f850160051c820191505b818110156128dc578281556001016128c9565b505050505050565b815167ffffffffffffffff8111156128fe576128fe612485565b6129128161290c84546125e1565b84612896565b602080601f831160018114612965576000841561292f5750858301515b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600386901b1c1916600185901b1785556128dc565b6000858152602081207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08616915b828110156129b257888601518255948401946001909101908401612993565b50858210156129ee57878501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600388901b60f8161c191681555b5050505050600190811b01905550565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fdfea2646970667358221220ab474899210c5edd2abad06aea5ee6e7b096250d38b0dc2c568d711a2b30176964736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436106101c25760003560e01c80636c0360eb116100f757806395d89b4111610095578063c87b56dd11610064578063c87b56dd146104be578063e7572230146104de578063e985e9c5146104fe578063f2fde38b1461055457600080fd5b806395d89b4114610454578063a22cb46514610469578063a7f93ebd14610489578063b88d4fde1461049e57600080fd5b80638da5cb5b116100d15780638da5cb5b146103de57806390901aa31461040957806390d340e11461042957806391ba317a1461043f57600080fd5b80636c0360eb1461039457806370a08231146103a9578063715018a6146103c957600080fd5b80632ae6218d1161016457806342966c681161013e57806342966c681461032c5780634f6ccce71461034c5780636352211e1461036c57806369ebf34e1461038c57600080fd5b80632ae6218d146102d75780632f745c59146102ec57806342842e0e1461030c57600080fd5b8063095ea7b3116101a0578063095ea7b31461026357806312065fe01461028557806318160ddd146102a257806323b872dd146102b757600080fd5b806301ffc9a7146101c757806306fdde03146101fc578063081812fc1461021e575b600080fd5b3480156101d357600080fd5b506101e76101e23660046122e8565b610574565b60405190151581526020015b60405180910390f35b34801561020857600080fd5b50610211610585565b6040516101f39190612373565b34801561022a57600080fd5b5061023e610239366004612386565b610617565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101f3565b34801561026f57600080fd5b5061028361027e3660046123c8565b61064d565b005b34801561029157600080fd5b50475b6040519081526020016101f3565b3480156102ae57600080fd5b50600954610294565b3480156102c357600080fd5b506102836102d23660046123f2565b61065c565b3480156102e357600080fd5b50610294610752565b3480156102f857600080fd5b506102946103073660046123c8565b610776565b34801561031857600080fd5b506102836103273660046123f2565b61080e565b34801561033857600080fd5b50610283610347366004612386565b61082e565b34801561035857600080fd5b50610294610367366004612386565b61083a565b34801561037857600080fd5b5061023e610387366004612386565b6108ac565b6102836108b7565b3480156103a057600080fd5b506102116108c1565b3480156103b557600080fd5b506102946103c436600461242e565b61094f565b3480156103d557600080fd5b506102836109ca565b3480156103ea57600080fd5b50600b5473ffffffffffffffffffffffffffffffffffffffff1661023e565b34801561041557600080fd5b50610283610424366004612386565b6109dc565b34801561043557600080fd5b50610294600c5481565b34801561044b57600080fd5b50600c54610294565b34801561046057600080fd5b50610211610a99565b34801561047557600080fd5b50610283610484366004612449565b610aa8565b34801561049557600080fd5b50610294610ab3565b3480156104aa57600080fd5b506102836104b93660046124b4565b610acc565b3480156104ca57600080fd5b506102116104d9366004612386565b610ae3565b3480156104ea57600080fd5b506102946104f9366004612386565b610aee565b34801561050a57600080fd5b506101e76105193660046125ae565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260056020908152604080832093909416825291909152205460ff1690565b34801561056057600080fd5b5061028361056f36600461242e565b610af9565b600061057f82610b5d565b92915050565b606060008054610594906125e1565b80601f01602080910402602001604051908101604052809291908181526020018280546105c0906125e1565b801561060d5780601f106105e25761010080835404028352916020019161060d565b820191906000526020600020905b8154815290600101906020018083116105f057829003601f168201915b5050505050905090565b600061062282610bb3565b5060008281526004602052604090205473ffffffffffffffffffffffffffffffffffffffff1661057f565b610658828233610c12565b5050565b73ffffffffffffffffffffffffffffffffffffffff82166106b1576040517f64a0ae92000000000000000000000000000000000000000000000000000000008152600060048201526024015b60405180910390fd5b60006106be838333610c1f565b90508373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161461074c576040517f64283d7b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808616600483015260248201849052821660448201526064016106a8565b50505050565b6000610771600161076260095490565b61076c9190612663565b610c34565b905090565b60006107818361094f565b82106107d8576040517fa57d13dc00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152602481018390526044016106a8565b5073ffffffffffffffffffffffffffffffffffffffff919091166000908152600760209081526040808320938352929052205490565b61082983838360405180602001604052806000815250610acc565b505050565b61065860008233610c1f565b600061084560095490565b8210610887576040517fa57d13dc00000000000000000000000000000000000000000000000000000000815260006004820152602481018390526044016106a8565b6009828154811061089a5761089a612676565b90600052602060002001549050919050565b600061057f82610bb3565b6108bf610ca3565b565b600d80546108ce906125e1565b80601f01602080910402602001604051908101604052809291908181526020018280546108fa906125e1565b80156109475780601f1061091c57610100808354040283529160200191610947565b820191906000526020600020905b81548152906001019060200180831161092a57829003601f168201915b505050505081565b600073ffffffffffffffffffffffffffffffffffffffff82166109a1576040517f89c62b64000000000000000000000000000000000000000000000000000000008152600060048201526024016106a8565b5073ffffffffffffffffffffffffffffffffffffffff1660009081526003602052604090205490565b6109d2610d7e565b6108bf6000610dd1565b60006109e73361094f565b905080821115610a53576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4b65792062616c616e6365206e6f7420656e6f7567680000000000000000000060448201526064016106a8565b60005b8281101561082957610a6f33610a6a610752565b610e48565b6000610a7b3383610776565b9050610a8681610f32565b5080610a91816126a5565b915050610a56565b606060018054610594906125e1565b610658338383610f93565b6000610771610ac160095490565b61076c9060016126dd565b610ad784848461065c565b61074c84848484611090565b606061057f82611287565b600061057f82610c34565b610b01610d7e565b73ffffffffffffffffffffffffffffffffffffffff8116610b51576040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600060048201526024016106a8565b610b5a81610dd1565b50565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f780e9d6300000000000000000000000000000000000000000000000000000000148061057f575061057f82611390565b60008181526002602052604081205473ffffffffffffffffffffffffffffffffffffffff168061057f576040517f7e273289000000000000000000000000000000000000000000000000000000008152600481018490526024016106a8565b61082983838360016113e6565b6000610c2c8484846115b1565b949350505050565b60006702c68af0bb14000067016345785d8a0000662386f26fc1000083610c73610c5e87846126f0565b610c7090670de0b6b3a76400006126dd565b90565b90506000610c80826116cc565b90506000610c97610c918784611701565b86611717565b98975050505050505050565b610cab610ab3565b341015610d14576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f496e73756666696369656e74207061796d656e7400000000000000000000000060448201526064016106a8565b600c546000610d2282611726565b9050610d2e3383611792565b610d3882826117ac565b600c8054906000610d48836126a5565b9091555050604051829033907f4cc0a9c4a99ddc700de1af2c9f916a7cbfdb71f14801ccff94061ad1ef8a804090600090a35050565b600b5473ffffffffffffffffffffffffffffffffffffffff1633146108bf576040517f118cdaa70000000000000000000000000000000000000000000000000000000081523360048201526024016106a8565b600b805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b8015610658576040805160008082526020820190925273ffffffffffffffffffffffffffffffffffffffff8416908390604051610e859190612707565b60006040518083038185875af1925050503d8060008114610ec2576040519150601f19603f3d011682016040523d82523d6000602084013e610ec7565b606091505b5050905080610829576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f455448207472616e73666572206661696c65640000000000000000000000000060448201526064016106a8565b6000610f416000836000610c1f565b905073ffffffffffffffffffffffffffffffffffffffff8116610658576040517f7e273289000000000000000000000000000000000000000000000000000000008152600481018390526024016106a8565b73ffffffffffffffffffffffffffffffffffffffff8216610ff8576040517f5b08ba1800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff831660048201526024016106a8565b73ffffffffffffffffffffffffffffffffffffffff83811660008181526005602090815260408083209487168084529482529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b73ffffffffffffffffffffffffffffffffffffffff83163b1561074c576040517f150b7a0200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84169063150b7a0290611105903390889087908790600401612723565b6020604051808303816000875af192505050801561115e575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261115b91810190612762565b60015b6111ed573d80801561118c576040519150601f19603f3d011682016040523d82523d6000602084013e611191565b606091505b5080516000036111e5576040517f64a0ae9200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff851660048201526024016106a8565b805181602001fd5b7fffffffff0000000000000000000000000000000000000000000000000000000081167f150b7a020000000000000000000000000000000000000000000000000000000014611280576040517f64a0ae9200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff851660048201526024016106a8565b5050505050565b606061129282610bb3565b50600082815260066020526040812080546112ac906125e1565b80601f01602080910402602001604051908101604052809291908181526020018280546112d8906125e1565b80156113255780601f106112fa57610100808354040283529160200191611325565b820191906000526020600020905b81548152906001019060200180831161130857829003601f168201915b50505050509050600061134360408051602081019091526000815290565b90508051600003611355575092915050565b81511561138757808260405160200161136f92919061277f565b60405160208183030381529060405292505050919050565b610c2c846117fc565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f4906490600000000000000000000000000000000000000000000000000000000148061057f575061057f8261185a565b8080611407575073ffffffffffffffffffffffffffffffffffffffff821615155b1561155c57600061141784610bb3565b905073ffffffffffffffffffffffffffffffffffffffff83161580159061146a57508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614155b80156114a9575073ffffffffffffffffffffffffffffffffffffffff80821660009081526005602090815260408083209387168352929052205460ff16155b156114f8576040517fa9fbf51f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff841660048201526024016106a8565b811561155a57838573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45b505b5050600090815260046020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b6000806115bf85858561193d565b905073ffffffffffffffffffffffffffffffffffffffff81166116295761162484600980546000838152600a60205260408120829055600182018355919091527f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af0155565b611666565b8473ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614611666576116668185611aba565b73ffffffffffffffffffffffffffffffffffffffff851661168f5761168a84611b65565b610c2c565b8473ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610c2c57610c2c8585611c14565b600061057f6714057b7ef767814f670de0b6b3a76400006116ef610c7086611c71565b02816116fd576116fd6127ae565b0490565b6000611710610c708484611dd7565b9392505050565b6000611710610c7083856126dd565b60408051808201909152600581527f2e6a736f6e0000000000000000000000000000000000000000000000000000006020820152606090600d61176884611ede565b8260405160200161177b939291906127dd565b604051602081830303815290604052915050919050565b610658828260405180602001604052806000815250611f9c565b60008281526006602052604090206117c482826128e4565b506040518281527ff8e1a15aba9398e019f0b49df1a4fde98ee17ae345cb5f6b5e2c27f5033e8ce79060200160405180910390a15050565b606061180782610bb3565b50600061181f60408051602081019091526000815290565b9050600081511161183f5760405180602001604052806000815250611710565b8061184984611ede565b60405160200161177b92919061277f565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f80ac58cd0000000000000000000000000000000000000000000000000000000014806118ed57507fffffffff0000000000000000000000000000000000000000000000000000000082167f5b5e139f00000000000000000000000000000000000000000000000000000000145b8061057f57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff0000000000000000000000000000000000000000000000000000000083161461057f565b60008281526002602052604081205473ffffffffffffffffffffffffffffffffffffffff9081169083161561197757611977818486611fb3565b73ffffffffffffffffffffffffffffffffffffffff8116156119ed576119a16000856000806113e6565b73ffffffffffffffffffffffffffffffffffffffff8116600090815260036020526040902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190555b73ffffffffffffffffffffffffffffffffffffffff851615611a365773ffffffffffffffffffffffffffffffffffffffff85166000908152600360205260409020805460010190555b60008481526002602052604080822080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff89811691821790925591518793918516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4949350505050565b6000611ac58361094f565b600083815260086020526040902054909150808214611b255773ffffffffffffffffffffffffffffffffffffffff841660009081526007602090815260408083208584528252808320548484528184208190558352600890915290208190555b50600091825260086020908152604080842084905573ffffffffffffffffffffffffffffffffffffffff9094168352600781528383209183525290812055565b600954600090611b7790600190612663565b6000838152600a602052604081205460098054939450909284908110611b9f57611b9f612676565b906000526020600020015490508060098381548110611bc057611bc0612676565b6000918252602080832090910192909255828152600a90915260408082208490558582528120556009805480611bf857611bf86129fe565b6001900381819060005260206000200160009055905550505050565b60006001611c218461094f565b611c2b9190612663565b73ffffffffffffffffffffffffffffffffffffffff9093166000908152600760209081526040808320868452825280832085905593825260089052919091209190915550565b600081670de0b6b3a7640000811015611cb9576040517f36d32ef0000000000000000000000000000000000000000000000000000000008152600481018490526024016106a8565b6000611d45670de0b6b3a7640000830460016fffffffffffffffffffffffffffffffff821160071b91821c67ffffffffffffffff811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211871b91821c969096119490961792909217171791909117919091171790565b9050670de0b6b3a7640000810282821c7ffffffffffffffffffffffffffffffffffffffffffffffffff21f494c589c00008101611d8857815b9695505050505050565b671bc16d674ec800006706f05b59d3b200005b8015611dcb57670de0b6b3a7640000838002049250818310611dc3579283019260019290921c915b60011c611d9b565b50919695505050505050565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84860984860292508281108382030391505080600003611e295750670de0b6b3a76400009004905061057f565b670de0b6b3a76400008110611e74576040517f5173648d00000000000000000000000000000000000000000000000000000000815260048101869052602481018590526044016106a8565b6000670de0b6b3a7640000858709620400008185030493109091037d40000000000000000000000000000000000000000000000000000000000002919091177faccb18165bd6fe31ae1cf318dc5b51eee0e1ba569b88cd74c1773b91fac106690291505092915050565b60606000611eeb83612063565b600101905060008167ffffffffffffffff811115611f0b57611f0b612485565b6040519080825280601f01601f191660200182016040528015611f35576020820181803683370190505b5090508181016020015b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff017f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8504945084611f3f57509392505050565b611fa68383612145565b6108296000848484611090565b611fbe8383836121f6565b6108295773ffffffffffffffffffffffffffffffffffffffff8316612012576040517f7e273289000000000000000000000000000000000000000000000000000000008152600481018290526024016106a8565b6040517f177e802f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83166004820152602481018290526044016106a8565b6000807a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106120ac577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000830492506040015b6d04ee2d6d415b85acef810000000083106120d8576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc1000083106120f657662386f26fc10000830492506010015b6305f5e100831061210e576305f5e100830492506008015b612710831061212257612710830492506004015b60648310612134576064830492506002015b600a831061057f5760010192915050565b73ffffffffffffffffffffffffffffffffffffffff8216612195576040517f64a0ae92000000000000000000000000000000000000000000000000000000008152600060048201526024016106a8565b60006121a383836000610c1f565b905073ffffffffffffffffffffffffffffffffffffffff811615610829576040517f73c6ac6e000000000000000000000000000000000000000000000000000000008152600060048201526024016106a8565b600073ffffffffffffffffffffffffffffffffffffffff831615801590610c2c57508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161480612284575073ffffffffffffffffffffffffffffffffffffffff80851660009081526005602090815260408083209387168352929052205460ff165b80610c2c57505060009081526004602052604090205473ffffffffffffffffffffffffffffffffffffffff908116911614919050565b7fffffffff0000000000000000000000000000000000000000000000000000000081168114610b5a57600080fd5b6000602082840312156122fa57600080fd5b8135611710816122ba565b60005b83811015612320578181015183820152602001612308565b50506000910152565b60008151808452612341816020860160208601612305565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006117106020830184612329565b60006020828403121561239857600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff811681146123c357600080fd5b919050565b600080604083850312156123db57600080fd5b6123e48361239f565b946020939093013593505050565b60008060006060848603121561240757600080fd5b6124108461239f565b925061241e6020850161239f565b9150604084013590509250925092565b60006020828403121561244057600080fd5b6117108261239f565b6000806040838503121561245c57600080fd5b6124658361239f565b91506020830135801515811461247a57600080fd5b809150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080600080608085870312156124ca57600080fd5b6124d38561239f565b93506124e16020860161239f565b925060408501359150606085013567ffffffffffffffff8082111561250557600080fd5b818701915087601f83011261251957600080fd5b81358181111561252b5761252b612485565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190838211818310171561257157612571612485565b816040528281528a602084870101111561258a57600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b600080604083850312156125c157600080fd5b6125ca8361239f565b91506125d86020840161239f565b90509250929050565b600181811c908216806125f557607f821691505b60208210810361262e577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8181038181111561057f5761057f612634565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036126d6576126d6612634565b5060010190565b8082018082111561057f5761057f612634565b808202811582820484141761057f5761057f612634565b60008251612719818460208701612305565b9190910192915050565b600073ffffffffffffffffffffffffffffffffffffffff808716835280861660208401525083604083015260806060830152611d7e6080830184612329565b60006020828403121561277457600080fd5b8151611710816122ba565b60008351612791818460208801612305565b8351908301906127a5818360208801612305565b01949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008085546127eb816125e1565b60018281168015612803576001811461283657612865565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0084168752821515830287019450612865565b8960005260208060002060005b8581101561285c5781548a820152908401908201612843565b50505082870194505b505050508451612879818360208901612305565b845191019061288c818360208801612305565b0195945050505050565b601f82111561082957600081815260208120601f850160051c810160208610156128bd5750805b601f850160051c820191505b818110156128dc578281556001016128c9565b505050505050565b815167ffffffffffffffff8111156128fe576128fe612485565b6129128161290c84546125e1565b84612896565b602080601f831160018114612965576000841561292f5750858301515b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600386901b1c1916600185901b1785556128dc565b6000858152602081207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08616915b828110156129b257888601518255948401946001909101908401612993565b50858210156129ee57878501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600388901b60f8161c191681555b5050505050600190811b01905550565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fdfea2646970667358221220ab474899210c5edd2abad06aea5ee6e7b096250d38b0dc2c568d711a2b30176964736f6c63430008140033",
  "libraries": {},
  "devdoc": {
    "errors": {
      "ERC721EnumerableForbiddenBatchMint()": [
        {
          "details": "Batch mint is not allowed."
        }
      ],
      "ERC721IncorrectOwner(address,uint256,address)": [
        {
          "details": "Indicates an error related to the ownership over a particular token. Used in transfers.",
          "params": {
            "owner": "Address of the current owner of a token.",
            "sender": "Address whose tokens are being transferred.",
            "tokenId": "Identifier number of a token."
          }
        }
      ],
      "ERC721InsufficientApproval(address,uint256)": [
        {
          "details": "Indicates a failure with the `operator`s approval. Used in transfers.",
          "params": {
            "operator": "Address that may be allowed to operate on tokens without being their owner.",
            "tokenId": "Identifier number of a token."
          }
        }
      ],
      "ERC721InvalidApprover(address)": [
        {
          "details": "Indicates a failure with the `approver` of a token to be approved. Used in approvals.",
          "params": {
            "approver": "Address initiating an approval operation."
          }
        }
      ],
      "ERC721InvalidOperator(address)": [
        {
          "details": "Indicates a failure with the `operator` to be approved. Used in approvals.",
          "params": {
            "operator": "Address that may be allowed to operate on tokens without being their owner."
          }
        }
      ],
      "ERC721InvalidOwner(address)": [
        {
          "details": "Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20. Used in balance queries.",
          "params": {
            "owner": "Address of the current owner of a token."
          }
        }
      ],
      "ERC721InvalidReceiver(address)": [
        {
          "details": "Indicates a failure with the token `receiver`. Used in transfers.",
          "params": {
            "receiver": "Address to which tokens are being transferred."
          }
        }
      ],
      "ERC721InvalidSender(address)": [
        {
          "details": "Indicates a failure with the token `sender`. Used in transfers.",
          "params": {
            "sender": "Address whose tokens are being transferred."
          }
        }
      ],
      "ERC721NonexistentToken(uint256)": [
        {
          "details": "Indicates a `tokenId` whose `owner` is the zero address.",
          "params": {
            "tokenId": "Identifier number of a token."
          }
        }
      ],
      "ERC721OutOfBoundsIndex(address,uint256)": [
        {
          "details": "An `owner`'s token query was out of bounds for `index`. NOTE: The owner being `address(0)` indicates a global out of bounds index."
        }
      ],
      "OwnableInvalidOwner(address)": [
        {
          "details": "The owner is not a valid owner account. (eg. `address(0)`)"
        }
      ],
      "OwnableUnauthorizedAccount(address)": [
        {
          "details": "The caller account is not authorized to perform an operation."
        }
      ]
    },
    "events": {
      "Approval(address,address,uint256)": {
        "details": "Emitted when `owner` enables `approved` to manage the `tokenId` token."
      },
      "ApprovalForAll(address,address,bool)": {
        "details": "Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."
      },
      "BatchMetadataUpdate(uint256,uint256)": {
        "details": "This event emits when the metadata of a range of tokens is changed. So that the third-party platforms such as NFT market could timely update the images and related attributes of the NFTs."
      },
      "MetadataUpdate(uint256)": {
        "details": "This event emits when the metadata of a token is changed. So that the third-party platforms such as NFT market could timely update the images and related attributes of the NFT."
      },
      "Transfer(address,address,uint256)": {
        "details": "Emitted when `tokenId` token is transferred from `from` to `to`."
      }
    },
    "kind": "dev",
    "methods": {
      "approve(address,uint256)": {
        "details": "See {IERC721-approve}."
      },
      "balanceOf(address)": {
        "details": "See {IERC721-balanceOf}."
      },
      "burn(uint256)": {
        "details": "Burns `tokenId`. See {ERC721-_burn}. Requirements: - The caller must own `tokenId` or be an approved operator."
      },
      "getApproved(uint256)": {
        "details": "See {IERC721-getApproved}."
      },
      "isApprovedForAll(address,address)": {
        "details": "See {IERC721-isApprovedForAll}."
      },
      "name()": {
        "details": "See {IERC721Metadata-name}."
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "ownerOf(uint256)": {
        "details": "See {IERC721-ownerOf}."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "safeTransferFrom(address,address,uint256)": {
        "details": "See {IERC721-safeTransferFrom}."
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "details": "See {IERC721-safeTransferFrom}."
      },
      "setApprovalForAll(address,bool)": {
        "details": "See {IERC721-setApprovalForAll}."
      },
      "symbol()": {
        "details": "See {IERC721Metadata-symbol}."
      },
      "tokenByIndex(uint256)": {
        "details": "See {IERC721Enumerable-tokenByIndex}."
      },
      "tokenOfOwnerByIndex(address,uint256)": {
        "details": "See {IERC721Enumerable-tokenOfOwnerByIndex}."
      },
      "totalSupply()": {
        "details": "See {IERC721Enumerable-totalSupply}."
      },
      "transferFrom(address,address,uint256)": {
        "details": "See {IERC721-transferFrom}."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "PRBMath_MulDiv18_Overflow(uint256,uint256)": [
        {
          "notice": "Thrown when the resultant value in {mulDiv18} overflows uint256."
        }
      ],
      "PRBMath_UD60x18_Log_InputTooSmall(uint256)": [
        {
          "notice": "Thrown when taking the logarithm of a number less than 1."
        }
      ]
    },
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 349,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_name",
        "offset": 0,
        "slot": "0",
        "type": "t_string_storage"
      },
      {
        "astId": 351,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_symbol",
        "offset": 0,
        "slot": "1",
        "type": "t_string_storage"
      },
      {
        "astId": 355,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_owners",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 359,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_balances",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 363,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_tokenApprovals",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 369,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_operatorApprovals",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 1901,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_tokenURIs",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_string_storage)"
      },
      {
        "astId": 1508,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_ownedTokens",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_uint256))"
      },
      {
        "astId": 1512,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_ownedTokensIndex",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 1515,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_allTokens",
        "offset": 0,
        "slot": "9",
        "type": "t_array(t_uint256)dyn_storage"
      },
      {
        "astId": 1519,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_allTokensIndex",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 8,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_owner",
        "offset": 0,
        "slot": "11",
        "type": "t_address"
      },
      {
        "astId": 10426,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "_maxTokenId",
        "offset": 0,
        "slot": "12",
        "type": "t_uint256"
      },
      {
        "astId": 10428,
        "contract": "contracts/tokens/PenXKey.sol:PenXKey",
        "label": "baseURI",
        "offset": 0,
        "slot": "13",
        "type": "t_string_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_string_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => string)",
        "numberOfBytes": "32",
        "value": "t_string_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}
